Water_vectorised_SIMD.cpp:21:41: note: ***** Analysis succeeded with vector mode V2DF
Water_vectorised_SIMD.cpp:21:41: note: SLPing BB part
Water_vectorised_SIMD.cpp:21:41: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63c38 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: <retval>.x = _5;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 <retval>.x = _5;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 <retval>.y = _7;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63cb8
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63cb8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _5 = scalar_3(D) * _4;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _5 = scalar_3(D) * _4;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _7 = scalar_3(D) * _6;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63d38 0x2b63db8
Water_vectorised_SIMD.cpp:21:41: note: node (external) 0x2b63d38 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: 	{ scalar_3(D), scalar_3(D) }
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63db8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _4 = y_2(D)->x;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _4 = y_2(D)->x;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _6 = y_2(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:21:41: note: Cost model analysis for part in loop 0:
  Vector cost: 48
  Scalar cost: 88
Water_vectorised_SIMD.cpp:21:41: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:21:41: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63c38 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: <retval>.x = _5;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 <retval>.x = _5;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 <retval>.y = _7;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63cb8
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63cb8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _5 = scalar_3(D) * _4;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _5 = scalar_3(D) * _4;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _7 = scalar_3(D) * _6;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63d38 0x2b63db8
Water_vectorised_SIMD.cpp:21:41: note: node (external) 0x2b63d38 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: 	{ scalar_3(D), scalar_3(D) }
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63db8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _4 = y_2(D)->x;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _4 = y_2(D)->x;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _6 = y_2(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: ------>vectorizing SLP node starting from: _4 = y_2(D)->x;
Water_vectorised_SIMD.cpp:21:41: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:21:41: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: y_2(D)->x
Water_vectorised_SIMD.cpp:21:41: note: created vectp.1084_15
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vect__4.1085_16 = MEM <const vector(2) double> [(double *)vectp.1084_15];
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vectp.1084_17 = vectp.1084_15 + 8;
Water_vectorised_SIMD.cpp:21:41: note: ------>vectorizing SLP node starting from: _5 = scalar_3(D) * _4;
Water_vectorised_SIMD.cpp:21:41: note: vect_is_simple_use: operand y_2(D)->x, type of def: internal
Water_vectorised_SIMD.cpp:21:41: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vect__5.1086_18 = _14 * vect__4.1085_16;
Water_vectorised_SIMD.cpp:21:41: note: ------>vectorizing SLP node starting from: <retval>.x = _5;
Water_vectorised_SIMD.cpp:21:41: note: vect_is_simple_use: operand scalar_3(D) * _4, type of def: internal
Water_vectorised_SIMD.cpp:21:41: note: vect_is_simple_use: operand scalar_3(D) * _6, type of def: internal
Water_vectorised_SIMD.cpp:21:41: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:21:41: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: <retval>.x
Water_vectorised_SIMD.cpp:21:41: note: created &<retval>
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: MEM <vector(2) double> [(double *)&<retval>] = vect__5.1086_18;
Water_vectorised_SIMD.cpp:21:41: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:21:41: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:21:41: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:21:41: note: ***** Analysis succeeded with vector mode V2DF
Water_vectorised_SIMD.cpp:21:41: note: SLPing BB part
Water_vectorised_SIMD.cpp:21:41: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63c38 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: <retval>.x = _7;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 <retval>.x = _7;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 <retval>.y = _12;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63cb8
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63cb8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _7 = _3 - _6;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _7 = _3 - _6;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _12 = _9 - _11;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63d38 0x2b63eb8
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63d38 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _3 = _1 * _2;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _3 = _1 * _2;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _9 = _4 * _8;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63db8 0x2b63e38
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63db8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _1 = a_17(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _1 = a_17(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _4 = a_17(D)->z;
Water_vectorised_SIMD.cpp:21:41: note: node (external) 0x2b63e38 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _2 = b_18(D)->z;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _8 = b_18(D)->x;
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63eb8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _6 = _4 * _5;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _6 = _4 * _5;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _11 = _2 * _10;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63fb8 0x2b64038
Water_vectorised_SIMD.cpp:21:41: note: node (external) 0x2b63fb8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _4 = a_17(D)->z;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _10 = a_17(D)->x;
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b64038 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _5 = b_18(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _5 = b_18(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _2 = b_18(D)->z;
Water_vectorised_SIMD.cpp:21:41: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:21:41: note: Cost model analysis for part in loop 0:
  Vector cost: 100
  Scalar cost: 168
Water_vectorised_SIMD.cpp:21:41: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:21:41: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63c38 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: <retval>.x = _7;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 <retval>.x = _7;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 <retval>.y = _12;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63cb8
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63cb8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _7 = _3 - _6;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _7 = _3 - _6;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _12 = _9 - _11;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63d38 0x2b63eb8
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63d38 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _3 = _1 * _2;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _3 = _1 * _2;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _9 = _4 * _8;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63db8 0x2b63e38
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63db8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _1 = a_17(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _1 = a_17(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _4 = a_17(D)->z;
Water_vectorised_SIMD.cpp:21:41: note: node (external) 0x2b63e38 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _2 = b_18(D)->z;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _8 = b_18(D)->x;
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b63eb8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _6 = _4 * _5;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _6 = _4 * _5;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _11 = _2 * _10;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2b63fb8 0x2b64038
Water_vectorised_SIMD.cpp:21:41: note: node (external) 0x2b63fb8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _4 = a_17(D)->z;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _10 = a_17(D)->x;
Water_vectorised_SIMD.cpp:21:41: note: node 0x2b64038 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: _5 = b_18(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 _5 = b_18(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 _2 = b_18(D)->z;
Water_vectorised_SIMD.cpp:21:41: note: ------>vectorizing SLP node starting from: _1 = a_17(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:21:41: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: a_17(D)->y
Water_vectorised_SIMD.cpp:21:41: note: created vectp.1093_23
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vect__1.1094_24 = MEM <const vector(2) double> [(double *)vectp.1093_23];
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vectp.1093_25 = vectp.1093_23 + 8;
Water_vectorised_SIMD.cpp:21:41: note: extracting lane for live stmt _1 = a_17(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: ------>vectorizing SLP node starting from: _3 = _1 * _2;
Water_vectorised_SIMD.cpp:21:41: note: vect_is_simple_use: operand a_17(D)->y, type of def: internal
Water_vectorised_SIMD.cpp:21:41: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vect__3.1095_28 = vect__1.1094_24 * _27;
Water_vectorised_SIMD.cpp:21:41: note: ------>vectorizing SLP node starting from: _5 = b_18(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:21:41: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: b_18(D)->z
Water_vectorised_SIMD.cpp:21:41: note: created vectp.1097_30
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vectp.1097_31 = vectp.1097_30 + 18446744073709551608;
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vect__5.1098_32 = MEM <const vector(2) double> [(double *)vectp.1097_31];
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vectp.1097_33 = vectp.1097_31 + 8;
Water_vectorised_SIMD.cpp:21:41: note: extracting lane for live stmt _5 = b_18(D)->y;
Water_vectorised_SIMD.cpp:21:41: note: ------>vectorizing SLP node starting from: _6 = _4 * _5;
Water_vectorised_SIMD.cpp:21:41: note: vect_is_simple_use: operand b_18(D)->y, type of def: internal
Water_vectorised_SIMD.cpp:21:41: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vect__6.1099_35 = _29 * vect__5.1098_32;
Water_vectorised_SIMD.cpp:21:41: note: ------>vectorizing SLP node starting from: _7 = _3 - _6;
Water_vectorised_SIMD.cpp:21:41: note: vect_is_simple_use: operand _1 * _2, type of def: internal
Water_vectorised_SIMD.cpp:21:41: note: vect_is_simple_use: operand _4 * _5, type of def: internal
Water_vectorised_SIMD.cpp:21:41: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: vect__7.1100_36 = vect__3.1095_28 - vect__6.1099_35;
Water_vectorised_SIMD.cpp:21:41: note: ------>vectorizing SLP node starting from: <retval>.x = _7;
Water_vectorised_SIMD.cpp:21:41: note: vect_is_simple_use: operand _3 - _6, type of def: internal
Water_vectorised_SIMD.cpp:21:41: note: vect_is_simple_use: operand _9 - _11, type of def: internal
Water_vectorised_SIMD.cpp:21:41: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:21:41: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: <retval>.x
Water_vectorised_SIMD.cpp:21:41: note: created &<retval>
Water_vectorised_SIMD.cpp:21:41: note: add new stmt: MEM <vector(2) double> [(double *)&<retval>] = vect__7.1100_36;
Water_vectorised_SIMD.cpp:21:41: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:21:41: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:21:41: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:66:44: note: ***** Analysis failed with vector mode V2DF
Water_vectorised_SIMD.cpp:66:44: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:66:44: note: ***** Re-trying analysis with vector mode V8QI
Water_vectorised_SIMD.cpp:66:44: note: ***** Analysis failed with vector mode V8QI
Water_vectorised_SIMD.cpp:66:44: note: ***** The result for vector mode V4QI would be the same
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
Water_vectorised_SIMD.cpp:124:7: note: vectorized 0 loops in function.
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_36, _42);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_114, _43);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_15, _44);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_9, _45);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_57, _75);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_63, _76);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_69, _77);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_78, _82);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_135, _84);
Water_vectorised_SIMD.cpp:124:7: note: ***** Analysis failed with vector mode V2DI
Water_vectorised_SIMD.cpp:124:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/predefined_ops.h:270:17: missed: couldn't vectorize loop
/usr/include/c++/13/bits/predefined_ops.h:270:17: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_heap.h:422:31: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_heap.h:422:31: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
/usr/include/c++/13/bits/stl_iterator.h:1148:47: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_iterator.h:1148:47: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_heap.h:229:28: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_heap.h:229:28: missed: not vectorized: number of iterations cannot be computed.
/usr/include/c++/13/bits/stl_heap.h:229:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_heap.h:229:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_algo.h:1636:54: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_algo.h:1636:54: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_heap.h:229:28: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_heap.h:229:28: missed: not vectorized: number of iterations cannot be computed.
/usr/include/c++/13/bits/stl_heap.h:229:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_heap.h:229:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_heap.h:358:4: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_heap.h:358:4: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
/usr/include/c++/13/bits/stl_iterator.h:1148:47: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_iterator.h:1148:47: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_heap.h:229:28: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_heap.h:229:28: missed: not vectorized: number of iterations cannot be computed.
/usr/include/c++/13/bits/stl_heap.h:229:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_heap.h:229:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:1129:34: optimized: loop vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:180:6: note: vectorized 1 loops in function.
Water_vectorised_SIMD.cpp:180:6: missed: splitting region at control altering definition _174 = operator new (_293);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: statement clobbers memory: _157 = operator new (_156);
/usr/include/c++/13/bits/stl_algobase.h:931:11: missed: statement clobbers memory: __builtin_memset (__first_158, 0, _584);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _174 = operator new (_293);
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at dominance boundary bb11
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at control altering definition _566 = operator new (prephitmp_1192);
/usr/include/c++/13/bits/stl_algobase.h:931:11: missed: statement clobbers memory: __builtin_memset (__first_175, 0, _1188);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _566 = operator new (prephitmp_1192);
/usr/include/c++/13/bits/stl_heap.h:238:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_heap.h:238:28: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_heap.h:238:28: note: ***** Re-trying analysis with vector mode V8QI
/usr/include/c++/13/bits/stl_heap.h:238:28: note: ***** Analysis failed with vector mode V8QI
/usr/include/c++/13/bits/stl_heap.h:238:28: note: ***** Re-trying analysis with vector mode V4QI
/usr/include/c++/13/bits/stl_heap.h:238:28: note: ***** Analysis failed with vector mode V4QI
/usr/include/c++/13/bits/stl_heap.h:238:28: missed: splitting region at dominance boundary bb121
/usr/include/c++/13/bits/stl_heap.h:238:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_heap.h:238:28: missed: splitting region at dominance boundary bb122
/usr/include/c++/13/bits/vector.tcc:523:53: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/vector.tcc:523:53: missed: splitting region at dominance boundary bb111
/usr/include/c++/13/bits/stl_uninitialized.h:1131:21: missed: statement clobbers memory: __builtin_memmove (iftmp.24_532, _548, _531);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_548, _567);
/usr/include/c++/13/bits/vector.tcc:521:30: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/vector.tcc:521:30: note: SLPing BB part
/usr/include/c++/13/bits/vector.tcc:521:30: note: Costing subgraph: 
/usr/include/c++/13/bits/vector.tcc:521:30: note: node 0x2b95c48 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: op template: MEM[(struct vector *)_97].D.161841._M_impl.D.161189._M_start = iftmp.24_532;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 0 MEM[(struct vector *)_97].D.161841._M_impl.D.161189._M_start = iftmp.24_532;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 1 MEM[(struct vector *)_97].D.161841._M_impl.D.161189._M_finish = _1212;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	children 0x2b95dc8
/usr/include/c++/13/bits/vector.tcc:521:30: note: node (external) 0x2b95dc8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	{ iftmp.24_532, _1212 }
/usr/include/c++/13/bits/vector.tcc:521:30: note: Cost model analysis: 
/usr/include/c++/13/bits/vector.tcc:521:30: note: Cost model analysis for part in loop 2:
  Vector cost: 32
  Scalar cost: 32
/usr/include/c++/13/bits/vector.tcc:521:30: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/vector.tcc:521:30: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/vector.tcc:521:30: note: node 0x2b95c48 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: op template: MEM[(struct vector *)_97].D.161841._M_impl.D.161189._M_start = iftmp.24_532;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 0 MEM[(struct vector *)_97].D.161841._M_impl.D.161189._M_start = iftmp.24_532;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 1 MEM[(struct vector *)_97].D.161841._M_impl.D.161189._M_finish = _1212;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	children 0x2b95dc8
/usr/include/c++/13/bits/vector.tcc:521:30: note: node (external) 0x2b95dc8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	{ iftmp.24_532, _1212 }
/usr/include/c++/13/bits/vector.tcc:521:30: note: ------>vectorizing SLP node starting from: MEM[(struct vector *)_97].D.161841._M_impl.D.161189._M_start = iftmp.24_532;
/usr/include/c++/13/bits/vector.tcc:521:30: note: vect_is_simple_use: operand iftmp.24_532 + _1211, type of def: internal
/usr/include/c++/13/bits/vector.tcc:521:30: note: transform store. ncopies = 1
/usr/include/c++/13/bits/vector.tcc:521:30: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct vector *)_97].D.161841._M_impl.D.161189._M_start
/usr/include/c++/13/bits/vector.tcc:521:30: note: created vectp.1201_238
/usr/include/c++/13/bits/vector.tcc:521:30: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int * *)vectp.1201_238] = _237;
/usr/include/c++/13/bits/vector.tcc:521:30: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/vector.tcc:521:30: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/vector.tcc:521:30: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/vector.tcc:521:30: missed: splitting region at dominance boundary bb109
/usr/include/c++/13/bits/stl_vector.h:1899:24: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("vector::_M_realloc_insert");
/usr/include/c++/13/bits/stl_vector.h:1899:24: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1899:24: missed: splitting region at dominance boundary bb72
/usr/include/c++/13/bits/stl_vector.h:1288:6: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:1288:6: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:1288:6: missed: splitting region at control altering definition _518 = operator new (prephitmp_1203);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _518 = operator new (prephitmp_1203);
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at dominance boundary bb101
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at dominance boundary bb102
/usr/include/c++/13/bits/vector.tcc:523:53: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/vector.tcc:523:53: missed: splitting region at dominance boundary bb92
/usr/include/c++/13/bits/stl_uninitialized.h:1131:21: missed: statement clobbers memory: __builtin_memmove (iftmp.24_484, _500, _483);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_500, _519);
/usr/include/c++/13/bits/vector.tcc:521:30: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/vector.tcc:521:30: note: SLPing BB part
/usr/include/c++/13/bits/vector.tcc:521:30: note: Costing subgraph: 
/usr/include/c++/13/bits/vector.tcc:521:30: note: node 0x2b95dc8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: op template: MEM[(struct vector *)_95].D.161841._M_impl.D.161189._M_start = iftmp.24_484;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 0 MEM[(struct vector *)_95].D.161841._M_impl.D.161189._M_start = iftmp.24_484;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 1 MEM[(struct vector *)_95].D.161841._M_impl.D.161189._M_finish = _1210;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	children 0x2b95cc8
/usr/include/c++/13/bits/vector.tcc:521:30: note: node (external) 0x2b95cc8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	{ iftmp.24_484, _1210 }
/usr/include/c++/13/bits/vector.tcc:521:30: note: Cost model analysis: 
/usr/include/c++/13/bits/vector.tcc:521:30: note: Cost model analysis for part in loop 2:
  Vector cost: 32
  Scalar cost: 32
/usr/include/c++/13/bits/vector.tcc:521:30: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/vector.tcc:521:30: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/vector.tcc:521:30: note: node 0x2b95dc8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: op template: MEM[(struct vector *)_95].D.161841._M_impl.D.161189._M_start = iftmp.24_484;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 0 MEM[(struct vector *)_95].D.161841._M_impl.D.161189._M_start = iftmp.24_484;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 1 MEM[(struct vector *)_95].D.161841._M_impl.D.161189._M_finish = _1210;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	children 0x2b95cc8
/usr/include/c++/13/bits/vector.tcc:521:30: note: node (external) 0x2b95cc8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	{ iftmp.24_484, _1210 }
/usr/include/c++/13/bits/vector.tcc:521:30: note: ------>vectorizing SLP node starting from: MEM[(struct vector *)_95].D.161841._M_impl.D.161189._M_start = iftmp.24_484;
/usr/include/c++/13/bits/vector.tcc:521:30: note: vect_is_simple_use: operand iftmp.24_484 + _1209, type of def: internal
/usr/include/c++/13/bits/vector.tcc:521:30: note: transform store. ncopies = 1
/usr/include/c++/13/bits/vector.tcc:521:30: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct vector *)_95].D.161841._M_impl.D.161189._M_start
/usr/include/c++/13/bits/vector.tcc:521:30: note: created vectp.1203_242
/usr/include/c++/13/bits/vector.tcc:521:30: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int * *)vectp.1203_242] = _1094;
/usr/include/c++/13/bits/vector.tcc:521:30: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/vector.tcc:521:30: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/vector.tcc:521:30: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/vector.tcc:521:30: missed: splitting region at dominance boundary bb136
/usr/include/c++/13/bits/stl_vector.h:1899:24: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("vector::_M_realloc_insert");
/usr/include/c++/13/bits/stl_vector.h:1899:24: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1899:24: missed: splitting region at dominance boundary bb140
Water_vectorised_SIMD.cpp:180:6: missed: not vectorized: statement can throw an exception: resx 13
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_174, _293);
Water_vectorised_SIMD.cpp:180:6: missed: not vectorized: statement can throw an exception: resx 11
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb90
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_157, _293);
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb128
/usr/include/c++/13/bits/stl_vector.h:1288:6: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:1288:6: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:1288:6: missed: splitting region at loop 2 exit at bb130
Water_vectorised_SIMD.cpp:209:32: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:209:32: missed: splitting region at dominance boundary bb70
Water_vectorised_SIMD.cpp:187:25: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:187:25: missed: splitting region at dominance boundary bb132
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_174, _293);
/usr/include/c++/13/bits/new_allocator.h:172:26: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: splitting region at dominance boundary bb153
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (iftmp.16_795, _798);
Water_vectorised_SIMD.cpp:220:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:220:1: missed: splitting region at dominance boundary bb129
Water_vectorised_SIMD.cpp:220:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:220:1: missed: splitting region at dominance boundary bb155
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: splitting region at dominance boundary bb156
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: splitting region at dominance boundary bb175
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: splitting region at dominance boundary bb158
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: splitting region at dominance boundary bb51
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: splitting region at dominance boundary bb182
Water_vectorised_SIMD.cpp:202:90: note: ***** Analysis failed with vector mode V2DI
Water_vectorised_SIMD.cpp:202:90: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
Water_vectorised_SIMD.cpp:202:90: missed: splitting region at dominance boundary bb162
Water_vectorised_SIMD.cpp:202:90: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:202:90: missed: splitting region at dominance boundary bb3
Water_vectorised_SIMD.cpp:202:90: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1910:24: missed: statement clobbers memory: std::__throw_length_error ("cannot create std::vector larger than max_size()");
/usr/include/c++/13/bits/stl_vector.h:1910:24: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:225:27: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:225:27: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
Water_vectorised_SIMD.cpp:230:17: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: not vectorized: no vectype for stmt: _81 = MEM[(struct vector *)_27 + 64B].D.162866._M_impl.D.162204._M_start;
 scalar_type: struct Vec3 *
Water_vectorised_SIMD.cpp:222:6: note: vectorized 1 loops in function.
Water_vectorised_SIMD.cpp:230:17: missed: statement clobbers memory: __builtin_memset (&D.210508, 0, 8);
Water_vectorised_SIMD.cpp:41:11: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:41:11: note: SLPing BB part
Water_vectorised_SIMD.cpp:41:11: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84c48 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_52].x = _46;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_52].x = _46;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_52].y = _48;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84cc8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84cc8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _46 = _45 - _61;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _46 = _45 - _61;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _48 = _47 - _62;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84d48 0x2b84dc8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84d48 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _45 = MEM[(struct Vec3 *)_52].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _45 = MEM[(struct Vec3 *)_52].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _47 = MEM[(struct Vec3 *)_52].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84dc8 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _61 = _29 * _72;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _61 = _29 * _72;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _62 = _29 * _75;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84e48 0x2b84ec8
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2b84e48 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _29, _29 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84ec8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _72 = _70 - _71;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _72 = _70 - _71;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _75 = _73 - _74;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84f48 0x2b84fc8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84f48 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _70 = MEM[(const struct Vec3 *)_80].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _70 = MEM[(const struct Vec3 *)_80].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _73 = MEM[(const struct Vec3 *)_80].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84fc8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _71 = MEM[(const struct Vec3 &)_83].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _71 = MEM[(const struct Vec3 &)_83].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _74 = MEM[(const struct Vec3 &)_83].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b850c8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_60].x = _54;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_60].x = _54;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_60].y = _56;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b85148
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b85148 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _54 = _53 + _61;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _54 = _53 + _61;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _56 = _55 + _62;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b851c8 0x2b84dc8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b851c8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _53 = MEM[(struct Vec3 *)_60].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _53 = MEM[(struct Vec3 *)_60].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _55 = MEM[(struct Vec3 *)_60].y;
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis for part in loop 4:
  Vector cost: 152
  Scalar cost: 264
Water_vectorised_SIMD.cpp:41:11: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84c48 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_52].x = _46;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_52].x = _46;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_52].y = _48;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84cc8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84cc8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _46 = _45 - _61;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _46 = _45 - _61;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _48 = _47 - _62;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84d48 0x2b84dc8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84d48 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _45 = MEM[(struct Vec3 *)_52].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _45 = MEM[(struct Vec3 *)_52].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _47 = MEM[(struct Vec3 *)_52].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84dc8 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _61 = _29 * _72;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _61 = _29 * _72;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _62 = _29 * _75;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84e48 0x2b84ec8
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2b84e48 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _29, _29 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84ec8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _72 = _70 - _71;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _72 = _70 - _71;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _75 = _73 - _74;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84f48 0x2b84fc8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84f48 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _70 = MEM[(const struct Vec3 *)_80].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _70 = MEM[(const struct Vec3 *)_80].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _73 = MEM[(const struct Vec3 *)_80].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84fc8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _71 = MEM[(const struct Vec3 &)_83].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _71 = MEM[(const struct Vec3 &)_83].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _74 = MEM[(const struct Vec3 &)_83].y;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _45 = MEM[(struct Vec3 *)_52].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_52].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1285_115
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__45.1286_104 = MEM <vector(2) double> [(double *)vectp.1285_115];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1285_111 = vectp.1285_115 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _70 = MEM[(const struct Vec3 *)_80].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_80].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1288_128
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__70.1289_127 = MEM <const vector(2) double> [(double *)vectp.1288_128];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1288_120 = vectp.1288_128 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _71 = MEM[(const struct Vec3 &)_83].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_83].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1291_33
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__71.1292_119 = MEM <const vector(2) double> [(double *)vectp.1291_33];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1291_99 = vectp.1291_33 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _72 = _70 - _71;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_80].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_83].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__72.1293_101 = vect__70.1289_127 - vect__71.1292_119;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _72 = _70 - _71;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _75 = _73 - _74;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _61 = _29 * _72;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _70 - _71, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__61.1294_121 = _129 * vect__72.1293_101;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _61 = _29 * _72;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _62 = _29 * _75;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _46 = _45 - _61;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_52].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _29 * _72, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__46.1295_86 = vect__45.1286_104 - vect__61.1294_121;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_52].x = _46;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _45 - _61, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _47 - _62, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_52].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1297_122
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1297_122] = vect__46.1295_86;
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b850c8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_60].x = _54;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_60].x = _54;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_60].y = _56;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b85148
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b85148 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _54 = _53 + _61;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _54 = _53 + _61;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _56 = _55 + _62;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b851c8 0x2b84dc8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b851c8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _53 = MEM[(struct Vec3 *)_60].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _53 = MEM[(struct Vec3 *)_60].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _55 = MEM[(struct Vec3 *)_60].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84dc8 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _61 = _29 * _72;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _61 = _29 * _72;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _62 = _29 * _75;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84e48 0x2b84ec8
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2b84e48 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _29, _29 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84ec8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _72 = _70 - _71;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _72 = _70 - _71;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _75 = _73 - _74;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2b84f48 0x2b84fc8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84f48 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _70 = MEM[(const struct Vec3 *)_80].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _70 = MEM[(const struct Vec3 *)_80].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _73 = MEM[(const struct Vec3 *)_80].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2b84fc8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _71 = MEM[(const struct Vec3 &)_83].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _71 = MEM[(const struct Vec3 &)_83].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _74 = MEM[(const struct Vec3 &)_83].y;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _53 = MEM[(struct Vec3 *)_60].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_60].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1299_16
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__53.1300_8 = MEM <vector(2) double> [(double *)vectp.1299_16];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1299_117 = vectp.1299_16 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _54 = _53 + _61;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_60].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _29 * _72, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__54.1301_118 = vect__53.1300_8 + vect__61.1294_121;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_60].x = _54;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _53 + _61, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _55 + _62, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_60].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1303_89
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1303_89] = vect__54.1301_118;
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:41:11: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:244:29: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:244:29: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
Water_vectorised_SIMD.cpp:250:17: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: not vectorized: no vectype for stmt: _173 = MEM[(struct vector *)_27 + 64B].D.162866._M_impl.D.162204._M_start;
 scalar_type: struct Vec3 *
Water_vectorised_SIMD.cpp:241:6: note: vectorized 1 loops in function.
Water_vectorised_SIMD.cpp:250:17: missed: statement clobbers memory: __builtin_memset (&D.210591, 0, 8);
Water_vectorised_SIMD.cpp:41:11: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:41:11: note: SLPing BB part
Water_vectorised_SIMD.cpp:41:11: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78c88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_66].x = _60;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_66].x = _60;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_66].y = _62;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78d08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78d08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _60 = _59 + _86;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _60 = _59 + _86;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _62 = _61 + _87;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78d88 0x2e78e08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78d88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _59 = MEM[(struct Vec3 *)_66].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _59 = MEM[(struct Vec3 *)_66].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _61 = MEM[(struct Vec3 *)_66].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78e08 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _86 = _40 * _92;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _86 = _40 * _92;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _87 = _40 * _93;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78e88 0x2e78f08
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e78e88 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _40, _40 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78f08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _92 = _103 / _100;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _92 = _103 / _100;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _93 = _106 / _100;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78f88 0x2e79b88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78f88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _103 = _101 - _102;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _103 = _101 - _102;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _106 = _104 - _105;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79008 0x2e79708
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79008 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _101 = _133 * _159;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _101 = _133 * _159;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _104 = _136 * _155;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79088 0x2e79508
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79088 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79108 0x2e79488
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79108 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _131 = _155 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _131 = _155 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79188 0x2e79308
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79188 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79208 0x2e79288
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79208 (max_nunits=2, refcnt=2) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79288 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79308 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79388 0x2e79408
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79388 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _168 = MEM[(const struct Vec3 *)_172].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79408 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _169 = MEM[(const struct Vec3 &)_175].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79488 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _132 = _159 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _132 = _159 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79508 0x2e79608
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79508 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79388 0x2e79588
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79588 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _158 = MEM[(const struct Vec3 &)_161].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79608 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79208 0x2e79688
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79688 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79708 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _102 = _136 * _157;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _102 = _136 * _157;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _105 = _130 * _159;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79788 0x2e79888
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79788 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _130 = _128 - _129;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79808 0x2e79a08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79808 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _128 = _159 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79888 0x2e79608
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79888 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79908 0x2e79988
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79908 (max_nunits=2, refcnt=2) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _168 = MEM[(const struct Vec3 *)_172].z;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79988 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _158 = MEM[(const struct Vec3 &)_161].z;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79a08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _129 = _157 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79188 0x2e79a88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79a88 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79908 0x2e79b08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79b08 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _169 = MEM[(const struct Vec3 &)_175].z;
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79b88 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _100, _100 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79c88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_74].x = _68;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_74].x = _68;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_74].y = _70;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79d08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79d08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _68 = _67 - _224;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _68 = _67 - _224;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _70 = _69 - _223;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79d88 0x2e79e08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79d88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _67 = MEM[(struct Vec3 *)_74].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _67 = MEM[(struct Vec3 *)_74].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _69 = MEM[(struct Vec3 *)_74].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79e08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _224 = _86 + _89;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _224 = _86 + _89;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _223 = _87 + _90;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78e08 0x2e79e88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79e88 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _89 = _39 * _110;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _89 = _39 * _110;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _90 = _39 * _111;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79f08 0x2e79f88
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79f08 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _39, _39 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79f88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _110 = _121 / _118;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _110 = _121 / _118;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _111 = _124 / _118;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a008 0x2e7a188
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a008 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _121 = _119 - _120;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _121 = _119 - _120;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _124 = _122 - _123;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a088 0x2e7a108
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a088 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _119 = _136 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _119 = _136 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _122 = _130 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79788 0x2e79a88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a108 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _120 = _133 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _120 = _133 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _123 = _136 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79088 0x2e79308
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e7a188 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _118, _118 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a288 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_85].x = _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_85].x = _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_85].y = _81;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a308
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a308 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _79 = _78 + _89;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _79 = _78 + _89;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _81 = _80 + _90;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a388 0x2e79e88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a388 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _78 = MEM[(struct Vec3 *)_85].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _78 = MEM[(struct Vec3 *)_85].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _80 = MEM[(struct Vec3 *)_85].y;
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis for part in loop 4:
  Vector cost: 704
  Scalar cost: 1024
Water_vectorised_SIMD.cpp:41:11: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78c88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_66].x = _60;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_66].x = _60;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_66].y = _62;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78d08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78d08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _60 = _59 + _86;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _60 = _59 + _86;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _62 = _61 + _87;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78d88 0x2e78e08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78d88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _59 = MEM[(struct Vec3 *)_66].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _59 = MEM[(struct Vec3 *)_66].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _61 = MEM[(struct Vec3 *)_66].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78e08 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _86 = _40 * _92;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _86 = _40 * _92;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _87 = _40 * _93;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78e88 0x2e78f08
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e78e88 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _40, _40 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78f08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _92 = _103 / _100;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _92 = _103 / _100;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _93 = _106 / _100;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78f88 0x2e79b88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78f88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _103 = _101 - _102;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _103 = _101 - _102;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _106 = _104 - _105;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79008 0x2e79708
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79008 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _101 = _133 * _159;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _101 = _133 * _159;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _104 = _136 * _155;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79088 0x2e79508
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79088 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79108 0x2e79488
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79108 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _131 = _155 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _131 = _155 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79188 0x2e79308
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79188 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79208 0x2e79288
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79208 (max_nunits=2, refcnt=2) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79288 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79308 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79388 0x2e79408
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79388 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _168 = MEM[(const struct Vec3 *)_172].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79408 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _169 = MEM[(const struct Vec3 &)_175].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79488 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _132 = _159 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _132 = _159 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79508 0x2e79608
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79508 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79388 0x2e79588
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79588 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _158 = MEM[(const struct Vec3 &)_161].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79608 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79208 0x2e79688
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79688 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79708 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _102 = _136 * _157;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _102 = _136 * _157;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _105 = _130 * _159;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79788 0x2e79888
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79788 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _130 = _128 - _129;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79808 0x2e79a08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79808 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _128 = _159 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79888 0x2e79608
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79888 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79908 0x2e79988
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79908 (max_nunits=2, refcnt=2) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _168 = MEM[(const struct Vec3 *)_172].z;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79988 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _158 = MEM[(const struct Vec3 &)_161].z;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79a08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _129 = _157 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79188 0x2e79a88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79a88 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79908 0x2e79b08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79b08 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _169 = MEM[(const struct Vec3 &)_175].z;
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79b88 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _100, _100 }
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _59 = MEM[(struct Vec3 *)_66].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_66].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1336_226
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__59.1337_186 = MEM <vector(2) double> [(double *)vectp.1336_226];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1336_193 = vectp.1336_226 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_172].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1339_239
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__162.1340_238 = MEM <const vector(2) double> [(double *)vectp.1339_239];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1339_231 = vectp.1339_239 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_161].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1342_45
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__154.1343_230 = MEM <const vector(2) double> [(double *)vectp.1342_45];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1342_7 = vectp.1342_45 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_172].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_161].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__155.1344_184 = vect__162.1340_238 - vect__154.1343_230;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__170.1345_213 = _232 - _189;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _131 = _155 * _170;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _162 - _154, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _168 - _169, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__131.1346_234 = vect__155.1344_184 * vect__170.1345_213;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__159.1347_4 = _232 - _5;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_175].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1349_243
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__163.1350_77 = MEM <const vector(2) double> [(double *)vectp.1349_243];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1349_225 = vectp.1349_243 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_172].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_175].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__164.1351_187 = vect__162.1340_238 - vect__163.1350_77;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _132 = _159 * _164;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _168 - _158, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _162 - _163, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__132.1352_75 = vect__159.1347_4 * vect__164.1351_187;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _155 * _170, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _159 * _164, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__133.1353_21 = vect__131.1346_234 - vect__132.1352_75;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _101 = _133 * _159;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _131 - _132, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _168 - _158, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__101.1354_22 = vect__133.1353_21 * vect__159.1347_4;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_172].y
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1356_24
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__165.1357_76 = MEM <const vector(2) double> [(double *)vectp.1356_24];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1356_177 = vectp.1356_24 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_161].y
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1359_246
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__156.1360_25 = MEM <const vector(2) double> [(double *)vectp.1359_246];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1359_18 = vectp.1359_246 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_172].y, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_161].y, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__157.1361_19 = vect__165.1357_76 - vect__156.1360_25;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _165 - _156, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _162 - _163, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__134.1362_220 = vect__157.1361_19 * vect__164.1351_187;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_175].y
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1364_219
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__166.1365_218 = MEM <const vector(2) double> [(double *)vectp.1364_219];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1364_217 = vectp.1364_219 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_172].y, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_175].y, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__167.1366_216 = vect__165.1357_76 - vect__166.1365_218;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _162 - _154, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _165 - _166, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__135.1367_203 = vect__155.1344_184 * vect__167.1366_216;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _157 * _164, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _155 * _167, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__136.1368_202 = vect__134.1362_220 - vect__135.1367_203;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _130 = _128 - _129;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _102 = _136 * _157;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _134 - _135, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _165 - _156, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__102.1369_197 = vect__136.1368_202 * vect__157.1361_19;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _103 = _101 - _102;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _133 * _159, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _136 * _157, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__103.1370_196 = vect__101.1354_22 - vect__102.1369_197;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _103 = _101 - _102;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _106 = _104 - _105;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _92 = _103 / _100;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _101 - _102, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__92.1371_181 = vect__103.1370_196 / _179;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _86 = _40 * _92;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _103 / _100, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__86.1372_212 = _240 * vect__92.1371_181;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _86 = _40 * _92;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _87 = _40 * _93;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _60 = _59 + _86;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_66].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _40 * _92, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__60.1373_8 = vect__59.1337_186 + vect__86.1372_212;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_66].x = _60;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _59 + _86, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _61 + _87, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_66].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1375_182
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1375_182] = vect__60.1373_8;
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79c88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_74].x = _68;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_74].x = _68;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_74].y = _70;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79d08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79d08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _68 = _67 - _224;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _68 = _67 - _224;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _70 = _69 - _223;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79d88 0x2e79e08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79d88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _67 = MEM[(struct Vec3 *)_74].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _67 = MEM[(struct Vec3 *)_74].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _69 = MEM[(struct Vec3 *)_74].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79e08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _224 = _86 + _89;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _224 = _86 + _89;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _223 = _87 + _90;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78e08 0x2e79e88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78e08 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _86 = _40 * _92;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _86 = _40 * _92;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _87 = _40 * _93;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78e88 0x2e78f08
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e78e88 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _40, _40 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78f08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _92 = _103 / _100;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _92 = _103 / _100;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _93 = _106 / _100;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e78f88 0x2e79b88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e78f88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _103 = _101 - _102;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _103 = _101 - _102;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _106 = _104 - _105;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79008 0x2e79708
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79008 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _101 = _133 * _159;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _101 = _133 * _159;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _104 = _136 * _155;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79088 0x2e79508
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79088 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79108 0x2e79488
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79108 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _131 = _155 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _131 = _155 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79188 0x2e79308
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79188 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79208 0x2e79288
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79208 (max_nunits=2, refcnt=2) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79288 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79308 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79388 0x2e79408
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79388 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _168 = MEM[(const struct Vec3 *)_172].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79408 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _169 = MEM[(const struct Vec3 &)_175].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79488 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _132 = _159 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _132 = _159 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79508 0x2e79608
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79508 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79388 0x2e79588
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79588 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _158 = MEM[(const struct Vec3 &)_161].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79608 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79208 0x2e79688
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79688 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79708 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _102 = _136 * _157;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _102 = _136 * _157;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _105 = _130 * _159;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79788 0x2e79888
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79788 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _130 = _128 - _129;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79808 0x2e79a08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79808 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _128 = _159 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79888 0x2e79608
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79888 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79908 0x2e79988
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79908 (max_nunits=2, refcnt=2) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _168 = MEM[(const struct Vec3 *)_172].z;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79988 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _158 = MEM[(const struct Vec3 &)_161].z;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79a08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _129 = _157 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79188 0x2e79a88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79a88 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79908 0x2e79b08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79b08 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _169 = MEM[(const struct Vec3 &)_175].z;
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79b88 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _100, _100 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79e88 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _89 = _39 * _110;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _89 = _39 * _110;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _90 = _39 * _111;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79f08 0x2e79f88
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79f08 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _39, _39 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79f88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _110 = _121 / _118;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _110 = _121 / _118;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _111 = _124 / _118;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a008 0x2e7a188
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a008 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _121 = _119 - _120;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _121 = _119 - _120;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _124 = _122 - _123;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a088 0x2e7a108
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a088 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _119 = _136 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _119 = _136 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _122 = _130 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79788 0x2e79a88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a108 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _120 = _133 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _120 = _133 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _123 = _136 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79088 0x2e79308
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e7a188 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _118, _118 }
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _67 = MEM[(struct Vec3 *)_74].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_74].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1377_248
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__67.1378_249 = MEM <vector(2) double> [(double *)vectp.1377_248];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1377_250 = vectp.1377_248 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _119 = _136 * _167;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _134 - _135, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _165 - _166, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__119.1379_252 = vect__136.1368_202 * vect__167.1366_216;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _120 = _133 * _170;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _131 - _132, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _168 - _169, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__120.1380_253 = vect__133.1353_21 * vect__170.1345_213;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _121 = _119 - _120;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _136 * _167, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _133 * _170, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__121.1381_254 = vect__119.1379_252 - vect__120.1380_253;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _121 = _119 - _120;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _124 = _122 - _123;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _110 = _121 / _118;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _119 - _120, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__110.1382_258 = vect__121.1381_254 / _257;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _89 = _39 * _110;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _121 / _118, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__89.1383_259 = _251 * vect__110.1382_258;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _89 = _39 * _110;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _90 = _39 * _111;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _224 = _86 + _89;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _40 * _92, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _39 * _110, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__224.1384_262 = vect__86.1372_212 + vect__89.1383_259;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _68 = _67 - _224;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_74].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _86 + _89, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__68.1385_263 = vect__67.1378_249 - vect__224.1384_262;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_74].x = _68;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _67 - _224, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _69 - _223, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_74].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1387_264
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1387_264] = vect__68.1385_263;
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a288 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_85].x = _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_85].x = _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_85].y = _81;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a308
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a308 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _79 = _78 + _89;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _79 = _78 + _89;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _81 = _80 + _90;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a388 0x2e79e88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a388 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _78 = MEM[(struct Vec3 *)_85].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _78 = MEM[(struct Vec3 *)_85].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _80 = MEM[(struct Vec3 *)_85].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79e88 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _89 = _39 * _110;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _89 = _39 * _110;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _90 = _39 * _111;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79f08 0x2e79f88
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79f08 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _39, _39 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79f88 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _110 = _121 / _118;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _110 = _121 / _118;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _111 = _124 / _118;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a008 0x2e7a188
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a008 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _121 = _119 - _120;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _121 = _119 - _120;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _124 = _122 - _123;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e7a088 0x2e7a108
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a088 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _119 = _136 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _119 = _136 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _122 = _130 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79788 0x2e79a88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79788 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _130 = _128 - _129;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79808 0x2e79a08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79808 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _128 = _159 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79888 0x2e79608
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79888 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79908 0x2e79988
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79908 (max_nunits=2, refcnt=2) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _168 = MEM[(const struct Vec3 *)_172].z;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79988 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _158 = MEM[(const struct Vec3 &)_161].z;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79608 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79208 0x2e79688
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79208 (max_nunits=2, refcnt=2) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _165 = MEM[(const struct Vec3 *)_172].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79688 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79a08 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _129 = _157 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79188 0x2e79a88
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79188 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _157 = _165 - _156;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79208 0x2e79288
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79288 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _156 = MEM[(const struct Vec3 &)_161].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79a88 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _167 = _165 - _166;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79908 0x2e79b08
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79b08 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _166 = MEM[(const struct Vec3 &)_175].y;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _169 = MEM[(const struct Vec3 &)_175].z;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e7a108 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _120 = _133 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _120 = _133 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _123 = _136 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79088 0x2e79308
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79088 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _133 = _131 - _132;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _136 = _134 - _135;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79108 0x2e79488
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79108 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _131 = _155 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _131 = _155 * _170;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _134 = _157 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79188 0x2e79308
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79308 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _170 = _168 - _169;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _164 = _162 - _163;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79388 0x2e79408
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79388 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _168 = MEM[(const struct Vec3 *)_172].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _162 = MEM[(const struct Vec3 *)_172].x;
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79408 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _169 = MEM[(const struct Vec3 &)_175].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _163 = MEM[(const struct Vec3 &)_175].x;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79488 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _132 = _159 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _132 = _159 * _164;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _135 = _155 * _167;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79508 0x2e79608
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e79508 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _159 = _168 - _158;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _155 = _162 - _154;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e79388 0x2e79588
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e79588 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _158 = MEM[(const struct Vec3 &)_161].z;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _154 = MEM[(const struct Vec3 &)_161].x;
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e7a188 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _118, _118 }
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _78 = MEM[(struct Vec3 *)_85].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_85].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1389_266
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__78.1390_267 = MEM <vector(2) double> [(double *)vectp.1389_266];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1389_268 = vectp.1389_266 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _79 = _78 + _89;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_85].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _39 * _110, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__79.1391_269 = vect__78.1390_267 + vect__89.1383_259;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_85].x = _79;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _78 + _89, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _80 + _90, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_85].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1393_270
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1393_270] = vect__79.1391_269;
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:41:11: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:282:26: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:282:26: missed: not vectorized: multiple nested loops.
Water_vectorised_SIMD.cpp:283:36: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:283:36: missed: not vectorized: multiple nested loops.
Water_vectorised_SIMD.cpp:284:26: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:284:26: missed: not vectorized: control flow in loop.
Water_vectorised_SIMD.cpp:285:26: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:41:11: missed: not vectorized: complicated access pattern.
Water_vectorised_SIMD.cpp:278:6: note: vectorized 0 loops in function.
Water_vectorised_SIMD.cpp:41:11: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:41:11: note: SLPing BB part
Water_vectorised_SIMD.cpp:41:11: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc0e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_61].x = _55;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_61].x = _55;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_61].y = _57;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc168
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc168 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _55 = _54 - _70;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _55 = _54 - _70;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _57 = _56 - _71;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc1e8 0x2cfc268
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc1e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _54 = MEM[(struct Vec3 *)_61].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _54 = MEM[(struct Vec3 *)_61].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _56 = MEM[(struct Vec3 *)_61].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc268 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _70 = _21 * _80;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _70 = _21 * _80;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _71 = _21 * _83;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc2e8 0x2cfc368
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2cfc2e8 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _21, _21 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc368 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _80 = _78 - _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _80 = _78 - _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _83 = _81 - _82;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc3e8 0x2cfc468
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc3e8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _78 = MEM[(const struct Vec3 *)_88].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _78 = MEM[(const struct Vec3 *)_88].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _81 = MEM[(const struct Vec3 *)_88].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc468 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _79 = MEM[(const struct Vec3 &)_91].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _79 = MEM[(const struct Vec3 &)_91].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _82 = MEM[(const struct Vec3 &)_91].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc568 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_69].x = _63;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_69].x = _63;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_69].y = _65;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc5e8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc5e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _63 = _62 + _70;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _63 = _62 + _70;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _65 = _64 + _71;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc668 0x2cfc268
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc668 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _62 = MEM[(struct Vec3 *)_69].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _62 = MEM[(struct Vec3 *)_69].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _64 = MEM[(struct Vec3 *)_69].y;
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis for part in loop 4:
  Vector cost: 152
  Scalar cost: 264
Water_vectorised_SIMD.cpp:41:11: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc0e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_61].x = _55;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_61].x = _55;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_61].y = _57;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc168
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc168 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _55 = _54 - _70;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _55 = _54 - _70;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _57 = _56 - _71;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc1e8 0x2cfc268
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc1e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _54 = MEM[(struct Vec3 *)_61].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _54 = MEM[(struct Vec3 *)_61].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _56 = MEM[(struct Vec3 *)_61].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc268 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _70 = _21 * _80;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _70 = _21 * _80;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _71 = _21 * _83;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc2e8 0x2cfc368
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2cfc2e8 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _21, _21 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc368 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _80 = _78 - _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _80 = _78 - _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _83 = _81 - _82;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc3e8 0x2cfc468
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc3e8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _78 = MEM[(const struct Vec3 *)_88].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _78 = MEM[(const struct Vec3 *)_88].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _81 = MEM[(const struct Vec3 *)_88].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc468 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _79 = MEM[(const struct Vec3 &)_91].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _79 = MEM[(const struct Vec3 &)_91].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _82 = MEM[(const struct Vec3 &)_91].y;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _54 = MEM[(struct Vec3 *)_61].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_61].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1416_315
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__54.1417_314 = MEM <vector(2) double> [(double *)vectp.1416_315];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1416_313 = vectp.1416_315 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _78 = MEM[(const struct Vec3 *)_88].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_88].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1419_311
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__78.1420_310 = MEM <const vector(2) double> [(double *)vectp.1419_311];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1419_309 = vectp.1419_311 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _79 = MEM[(const struct Vec3 &)_91].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_91].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1422_308
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__79.1423_307 = MEM <const vector(2) double> [(double *)vectp.1422_308];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1422_306 = vectp.1422_308 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _80 = _78 - _79;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_88].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_91].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__80.1424_305 = vect__78.1420_310 - vect__79.1423_307;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _80 = _78 - _79;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _83 = _81 - _82;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _70 = _21 * _80;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _78 - _79, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__70.1425_302 = _312 * vect__80.1424_305;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _70 = _21 * _80;
Water_vectorised_SIMD.cpp:41:11: note: extracting lane for live stmt _71 = _21 * _83;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _55 = _54 - _70;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_61].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _21 * _80, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__55.1426_299 = vect__54.1417_314 - vect__70.1425_302;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_61].x = _55;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _54 - _70, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _56 - _71, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_61].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1428_298
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1428_298] = vect__55.1426_299;
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc568 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_69].x = _63;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_69].x = _63;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_69].y = _65;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc5e8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc5e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _63 = _62 + _70;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _63 = _62 + _70;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _65 = _64 + _71;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc668 0x2cfc268
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc668 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _62 = MEM[(struct Vec3 *)_69].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _62 = MEM[(struct Vec3 *)_69].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _64 = MEM[(struct Vec3 *)_69].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc268 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _70 = _21 * _80;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _70 = _21 * _80;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _71 = _21 * _83;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc2e8 0x2cfc368
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2cfc2e8 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _21, _21 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc368 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _80 = _78 - _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _80 = _78 - _79;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _83 = _81 - _82;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2cfc3e8 0x2cfc468
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc3e8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _78 = MEM[(const struct Vec3 *)_88].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _78 = MEM[(const struct Vec3 *)_88].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _81 = MEM[(const struct Vec3 *)_88].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2cfc468 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _79 = MEM[(const struct Vec3 &)_91].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _79 = MEM[(const struct Vec3 &)_91].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _82 = MEM[(const struct Vec3 &)_91].y;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _62 = MEM[(struct Vec3 *)_69].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_69].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1430_296
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__62.1431_295 = MEM <vector(2) double> [(double *)vectp.1430_296];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1430_294 = vectp.1430_296 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _63 = _62 + _70;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_69].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _21 * _80, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__63.1432_293 = vect__62.1431_295 + vect__70.1425_302;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_69].x = _63;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _62 + _70, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _64 + _71, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_69].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1434_292
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1434_292] = vect__63.1432_293;
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:41:11: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:311:27: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:316:24: missed: not vectorized: more than one data ref in stmt: *_53 = D.210681[_15];
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:316:24: missed: not vectorized: more than one data ref in stmt: *_53 = D.210681[_15];
Water_vectorised_SIMD.cpp:308:6: note: vectorized 0 loops in function.
Water_vectorised_SIMD.cpp:316:24: missed: not vectorized: more than one data ref in stmt: *_53 = D.210681[0];
Water_vectorised_SIMD.cpp:41:11: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:41:11: note: SLPing BB part
Water_vectorised_SIMD.cpp:41:11: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58c68 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_44].x = _38;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_44].x = _38;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_44].y = _40;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e58ce8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58ce8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _38 = _37 + _46;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _38 = _37 + _46;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _40 = _39 + _48;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e58d68 0x2e58de8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58d68 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _37 = MEM[(struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _37 = MEM[(struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _39 = MEM[(struct Vec3 *)_44].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58de8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _46 = _19 * _45;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _46 = _19 * _45;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _48 = _19 * _47;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e58e68 0x2e58ee8
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e58e68 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _19, _19 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58ee8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _45 = MEM[(const struct Vec3 *)_53].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _45 = MEM[(const struct Vec3 *)_53].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _47 = MEM[(const struct Vec3 *)_53].y;
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis for part in loop 2:
  Vector cost: 72
  Scalar cost: 136
Water_vectorised_SIMD.cpp:21:41: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:21:41: note: node 0x2e58fe8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: op template: MEM <struct Vec3[32]> [(struct Vec3 *)&D.210681][0].x = 0.0;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 0 MEM <struct Vec3[32]> [(struct Vec3 *)&D.210681][0].x = 0.0;
Water_vectorised_SIMD.cpp:21:41: note: 	stmt 1 MEM <struct Vec3[32]> [(struct Vec3 *)&D.210681][0].y = 0.0;
Water_vectorised_SIMD.cpp:21:41: note: 	children 0x2e59068
Water_vectorised_SIMD.cpp:21:41: note: node (constant) 0x2e59068 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:21:41: note: 	{ 0.0, 0.0 }
Water_vectorised_SIMD.cpp:21:41: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:21:41: note: Cost model analysis for part in loop 2:
  Vector cost: 28
  Scalar cost: 32
Water_vectorised_SIMD.cpp:41:11: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e59168 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_30].x = _16;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_30].x = _16;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_30].y = _26;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e591e8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e591e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _16 = _20 + _32;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _16 = _20 + _32;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _26 = _12 + _34;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e59268 0x2e592e8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e59268 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _20 = MEM[(struct Vec3 *)_30].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _20 = MEM[(struct Vec3 *)_30].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _12 = MEM[(struct Vec3 *)_30].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e592e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _32 = _22 * _31;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _32 = _22 * _31;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _34 = _22 * _33;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e59368 0x2e593e8
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e59368 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _22, _22 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e593e8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _31 = MEM[(const struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _31 = MEM[(const struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _33 = MEM[(const struct Vec3 *)_44].y;
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:41:11: note: Cost model analysis for part in loop 2:
  Vector cost: 72
  Scalar cost: 136
Water_vectorised_SIMD.cpp:41:11: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58c68 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_44].x = _38;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_44].x = _38;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_44].y = _40;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e58ce8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58ce8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _38 = _37 + _46;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _38 = _37 + _46;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _40 = _39 + _48;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e58d68 0x2e58de8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58d68 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _37 = MEM[(struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _37 = MEM[(struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _39 = MEM[(struct Vec3 *)_44].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58de8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _46 = _19 * _45;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _46 = _19 * _45;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _48 = _19 * _47;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e58e68 0x2e58ee8
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e58e68 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _19, _19 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58ee8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _45 = MEM[(const struct Vec3 *)_53].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _45 = MEM[(const struct Vec3 *)_53].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _47 = MEM[(const struct Vec3 *)_53].y;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _37 = MEM[(struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_44].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1464_15
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__37.1465_73 = MEM <vector(2) double> [(double *)vectp.1464_15];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1464_66 = vectp.1464_15 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _45 = MEM[(const struct Vec3 *)_53].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_53].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1467_57
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__45.1468_55 = MEM <const vector(2) double> [(double *)vectp.1467_57];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1467_6 = vectp.1467_57 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _46 = _19 * _45;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_53].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__46.1469_5 = _72 * vect__45.1468_55;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _38 = _37 + _46;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_44].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _19 * _45, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__38.1470_4 = vect__37.1465_73 + vect__46.1469_5;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_44].x = _38;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _37 + _46, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _39 + _48, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_44].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1472_75
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1472_75] = vect__38.1470_4;
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e58fe8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM <struct Vec3[32]> [(struct Vec3 *)&D.210681][0].x = 0.0;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM <struct Vec3[32]> [(struct Vec3 *)&D.210681][0].x = 0.0;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM <struct Vec3[32]> [(struct Vec3 *)&D.210681][0].y = 0.0;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e59068
Water_vectorised_SIMD.cpp:41:11: note: node (constant) 0x2e59068 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ 0.0, 0.0 }
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM <struct Vec3[32]> [(struct Vec3 *)&D.210681][0].x = 0.0;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand 0.0, type of def: constant
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM <struct Vec3[32]> [(struct Vec3 *)&D.210681][0].x
Water_vectorised_SIMD.cpp:41:11: note: created &MEM <struct Vec3[32]> [(struct Vec3 *)&D.210681][0]
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(struct Vec3 *)&D.210681] = { 0.0, 0.0 };
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:41:11: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e59168 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: MEM[(struct Vec3 *)_30].x = _16;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_30].x = _16;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_30].y = _26;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e591e8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e591e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _16 = _20 + _32;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _16 = _20 + _32;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _26 = _12 + _34;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e59268 0x2e592e8
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e59268 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _20 = MEM[(struct Vec3 *)_30].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _20 = MEM[(struct Vec3 *)_30].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _12 = MEM[(struct Vec3 *)_30].y;
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e592e8 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _32 = _22 * _31;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _32 = _22 * _31;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _34 = _22 * _33;
Water_vectorised_SIMD.cpp:41:11: note: 	children 0x2e59368 0x2e593e8
Water_vectorised_SIMD.cpp:41:11: note: node (external) 0x2e59368 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: 	{ _22, _22 }
Water_vectorised_SIMD.cpp:41:11: note: node 0x2e593e8 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:41:11: note: op template: _31 = MEM[(const struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 0 _31 = MEM[(const struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: 	stmt 1 _33 = MEM[(const struct Vec3 *)_44].y;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _20 = MEM[(struct Vec3 *)_30].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_30].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1476_78
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__20.1477_79 = MEM <vector(2) double> [(double *)vectp.1476_78];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1476_80 = vectp.1476_78 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _31 = MEM[(const struct Vec3 *)_44].x;
Water_vectorised_SIMD.cpp:41:11: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_44].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1479_82
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__31.1480_83 = MEM <const vector(2) double> [(double *)vectp.1479_82];
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vectp.1479_84 = vectp.1479_82 + 8;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _32 = _22 * _31;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_44].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__32.1481_85 = _81 * vect__31.1480_83;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: _16 = _20 + _32;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_30].x, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _22 * _31, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform binary/unary operation.
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: vect__16.1482_86 = vect__20.1477_79 + vect__32.1481_85;
Water_vectorised_SIMD.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_30].x = _16;
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _20 + _32, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: vect_is_simple_use: operand _12 + _34, type of def: internal
Water_vectorised_SIMD.cpp:41:11: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_30].x
Water_vectorised_SIMD.cpp:41:11: note: created vectp.1484_87
Water_vectorised_SIMD.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1484_87] = vect__16.1482_86;
Water_vectorised_SIMD.cpp:41:11: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:41:11: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:41:11: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_18, _33);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_12, _34);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_6, _35);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_36, _40);
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis failed with vector mode V2DI
Water_vectorised_SIMD.cpp:109:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
Water_vectorised_SIMD.cpp:368:26: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:368:26: missed: not vectorized: control flow in loop.
Water_vectorised_SIMD.cpp:368:26: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:368:26: missed: not vectorized: control flow in loop.
Water_vectorised_SIMD.cpp:364:6: note: vectorized 0 loops in function.
/usr/include/c++/13/ostream:223:25: missed: statement clobbers memory: _31 = std::basic_ostream<char>::_M_insert<double> (_1, _2);
/usr/include/c++/13/ostream:667:18: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_31, " ", 1);
/usr/include/c++/13/bits/basic_string.h:4037:30: missed: statement clobbers memory: _30 = std::__ostream_insert<char, std::char_traits<char> > (_31, _29, _28);
/usr/include/c++/13/ostream:667:18: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_30, " ", 1);
/usr/include/c++/13/ostream:223:25: missed: statement clobbers memory: _23 = std::basic_ostream<char>::_M_insert<double> (_30, _3);
/usr/include/c++/13/ostream:667:18: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_23, " ", 1);
/usr/include/c++/13/ostream:223:25: missed: statement clobbers memory: _20 = std::basic_ostream<char>::_M_insert<double> (_23, _4);
/usr/include/c++/13/ostream:667:18: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_20, " ", 1);
/usr/include/c++/13/ostream:223:25: missed: statement clobbers memory: _13 = std::basic_ostream<char>::_M_insert<double> (_20, _5);
/usr/include/c++/13/ostream:574:16: missed: statement clobbers memory: std::basic_ostream<char>::put (_13, 10);
/usr/include/c++/13/ostream:573:25: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_13, &__c, 1);
Water_vectorised_SIMD.cpp:375:1: note: ***** Analysis failed with vector mode V2DI
Water_vectorised_SIMD.cpp:375:1: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_vector.h:733:7: note: vectorized 0 loops in function.
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_18, _36);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_24, _37);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_30, _38);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_39, _43);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_68, _45);
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_vector.h:733:7: note: vectorized 0 loops in function.
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_17, _21);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_13, _23);
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_5, _8);
/usr/include/c++/13/bits/basic_string.h:284:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:284:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: not vectorized: control flow in loop.
Water_vectorised_SIMD.cpp:153:5: note: vectorized 0 loops in function.
Water_vectorised_SIMD.cpp:153:5: missed: splitting region at control altering definition _13 = operator new (_133);
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_95, "trajectory.txt", 14);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _13 = operator new (_133);
Water_vectorised_SIMD.cpp:153:58: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:153:58: note: SLPing BB part
Water_vectorised_SIMD.cpp:153:58: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:153:58: note: node 0x2e88c18 (max_nunits=2, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:153:58: note: op template: *this_19(D).steps = 10000;
Water_vectorised_SIMD.cpp:153:58: note: 	stmt 0 *this_19(D).steps = 10000;
Water_vectorised_SIMD.cpp:153:58: note: 	stmt 1 *this_19(D).no_mol = 100;
Water_vectorised_SIMD.cpp:153:58: note: 	children 0x2e88c98
Water_vectorised_SIMD.cpp:153:58: note: node (constant) 0x2e88c98 (max_nunits=1, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:153:58: note: 	{ 10000, 100 }
Water_vectorised_SIMD.cpp:153:58: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:153:58: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
Water_vectorised_SIMD.cpp:153:58: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:153:58: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:153:58: note: node 0x2e88c18 (max_nunits=2, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:153:58: note: op template: *this_19(D).steps = 10000;
Water_vectorised_SIMD.cpp:153:58: note: 	stmt 0 *this_19(D).steps = 10000;
Water_vectorised_SIMD.cpp:153:58: note: 	stmt 1 *this_19(D).no_mol = 100;
Water_vectorised_SIMD.cpp:153:58: note: 	children 0x2e88c98
Water_vectorised_SIMD.cpp:153:58: note: node (constant) 0x2e88c98 (max_nunits=1, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:153:58: note: 	{ 10000, 100 }
Water_vectorised_SIMD.cpp:153:58: note: ------>vectorizing SLP node starting from: *this_19(D).steps = 10000;
Water_vectorised_SIMD.cpp:153:58: note: vect_is_simple_use: operand 100, type of def: constant
Water_vectorised_SIMD.cpp:153:58: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:153:58: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: *this_19(D).steps
Water_vectorised_SIMD.cpp:153:58: note: created vectp.1540_296
Water_vectorised_SIMD.cpp:153:58: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int *)vectp.1540_296] = { 10000, 100 };
Water_vectorised_SIMD.cpp:153:58: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:153:58: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:153:58: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:153:58: missed: splitting region at dominance boundary bb11
Water_vectorised_SIMD.cpp:153:58: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:153:58: missed: splitting region at dominance boundary bb15
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb16
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_173, _43, _33);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at loop 1 exit at bb75
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _204 = __builtin_memcmp (_103, "-dt", 3);
/usr/include/c++/13/ext/string_conversions.h:82:34: missed: statement clobbers memory: _208 = strtof (_65, &__endptr);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb73
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: not vectorized: statement can throw an exception: std::__throw_out_of_range ("stof");
/usr/include/c++/13/ext/string_conversions.h:88:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: splitting region at dominance boundary bb81
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: not vectorized: statement can throw an exception: std::__throw_invalid_argument ("stof");
/usr/include/c++/13/ext/string_conversions.h:85:31: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: splitting region at dominance boundary bb40
Water_vectorised_SIMD.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 17
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Analysis failed with vector mode V4SI
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V4SI
/usr/include/c++/13/ext/string_conversions.h:66:41: missed: splitting region at loop 1 exit at bb140
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _172 = __builtin_memcmp (_299, "-no_mol", 7);
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _188 = __builtin_memcmp (_299, "-fwrite", 7);
/usr/include/c++/13/ext/string_conversions.h:82:34: missed: statement clobbers memory: _192 = strtol (_60, &__endptr, 10);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb139
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb60
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb57
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: not vectorized: statement can throw an exception: std::__throw_out_of_range ("stoi");
/usr/include/c++/13/ext/string_conversions.h:88:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: splitting region at dominance boundary bb66
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: not vectorized: statement can throw an exception: std::__throw_invalid_argument ("stoi");
/usr/include/c++/13/ext/string_conversions.h:85:31: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: splitting region at dominance boundary bb41
Water_vectorised_SIMD.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 16
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Analysis failed with vector mode V4SI
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V4SI
/usr/include/c++/13/ext/string_conversions.h:66:41: missed: splitting region at loop 1 exit at bb135
/usr/include/c++/13/ext/string_conversions.h:82:34: missed: statement clobbers memory: _176 = strtol (_55, &__endptr, 10);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb134
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb45
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb42
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: not vectorized: statement can throw an exception: std::__throw_out_of_range ("stoi");
/usr/include/c++/13/ext/string_conversions.h:88:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: splitting region at dominance boundary bb51
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: not vectorized: statement can throw an exception: std::__throw_invalid_argument ("stoi");
/usr/include/c++/13/ext/string_conversions.h:85:31: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: splitting region at dominance boundary bb23
Water_vectorised_SIMD.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 15
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Analysis failed with vector mode V4SI
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V4SI
/usr/include/c++/13/ext/string_conversions.h:66:41: missed: splitting region at loop 1 exit at bb131
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _156 = __builtin_memcmp (_383, "-steps", 6);
/usr/include/c++/13/ext/string_conversions.h:82:34: missed: statement clobbers memory: _160 = strtol (_27, &__endptr, 10);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb130
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb30
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb27
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: not vectorized: statement can throw an exception: std::__throw_out_of_range ("stoi");
/usr/include/c++/13/ext/string_conversions.h:88:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: splitting region at dominance boundary bb36
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: not vectorized: statement can throw an exception: std::__throw_invalid_argument ("stoi");
/usr/include/c++/13/ext/string_conversions.h:85:31: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: splitting region at dominance boundary bb17
Water_vectorised_SIMD.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 14
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Analysis failed with vector mode V4SI
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V4SI
/usr/include/c++/13/ext/string_conversions.h:66:41: missed: splitting region at dominance boundary bb71
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _143 = __builtin_memcmp (_114, "-h", 2);
/usr/include/c++/13/bits/basic_string.h:3731:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:3731:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:3731:9: missed: splitting region at dominance boundary bb109
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _217 = __builtin_memcmp (prephitmp_384, "-ofile", 6);
/usr/include/c++/13/bits/basic_string.h:3731:9: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:3731:9: missed: splitting region at loop 1 exit at bb110
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "---> error: the argument type is not recognized \n", 49);
/usr/include/c++/13/ostream:667:18: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:667:18: missed: splitting region at dominance boundary bb111
/usr/include/c++/13/ostream:667:18: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:667:18: missed: splitting region at dominance boundary bb86
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at loop 1 exit at bb151
/usr/include/c++/13/bits/new_allocator.h:134:2: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/new_allocator.h:134:2: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/new_allocator.h:134:2: missed: splitting region at dominance boundary bb94
/usr/include/c++/13/bits/new_allocator.h:134:2: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:134:2: missed: splitting region at dominance boundary bb99
/usr/include/c++/13/bits/basic_string.tcc:159:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:159:25: missed: splitting region at control altering definition _243 = operator new (_117);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _243 = operator new (_117);
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at dominance boundary bb101
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at dominance boundary bb105
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_244, _248);
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb108
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (prephitmp_129, _227, _219);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at dominance boundary bb112
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at loop 1 exit at bb115
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_105, _262);
Water_vectorised_SIMD.cpp:154:29: note: ***** Analysis failed with vector mode V2DI
Water_vectorised_SIMD.cpp:154:29: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
Water_vectorised_SIMD.cpp:154:29: missed: splitting region at dominance boundary bb116
Water_vectorised_SIMD.cpp:175:12: note: ***** Analysis failed with vector mode V2DF
Water_vectorised_SIMD.cpp:175:12: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DF
Water_vectorised_SIMD.cpp:175:12: missed: splitting region at dominance boundary bb123
Water_vectorised_SIMD.cpp:176:5: note: ***** Analysis failed with vector mode V2DF
Water_vectorised_SIMD.cpp:176:5: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DF
Water_vectorised_SIMD.cpp:176:5: missed: splitting region at dominance boundary bb150
Water_vectorised_SIMD.cpp:176:5: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:176:5: missed: splitting region at dominance boundary bb97
Water_vectorised_SIMD.cpp:176:5: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:176:5: missed: splitting region at dominance boundary bb91
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:140:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: splitting region at dominance boundary bb19
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("basic_string::_M_create");
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb118
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "MD -steps <number of steps> -no_mol <number of molecules>", 57);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, " -fwrite <io frequency> -dt <size of timestep> -ofile <filename> \n", 66);
/usr/include/c++/13/ostream:667:18: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:667:18: missed: splitting region at dominance boundary bb22
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&arg);
Water_vectorised_SIMD.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 7
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb7
Water_vectorised_SIMD.cpp:159:21: missed: statement clobbers memory: exit (0);
Water_vectorised_SIMD.cpp:159:21: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:159:21: missed: splitting region at dominance boundary bb5
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:140:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: splitting region at dominance boundary bb121
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("basic_string::_M_create");
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (_1);
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_vector.h:707:2: note: vectorized 0 loops in function.
/usr/include/c++/13/bits/stl_vector.h:707:2: missed: splitting region at control altering definition _34 = operator new (_47);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _34 = operator new (_47);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2a2a188 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)this_2(D)]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)this_2(D)]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)this_2(D)]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2a2a208
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2a2a208 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2a2a188 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)this_2(D)]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)this_2(D)]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)this_2(D)]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2a2a208
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2a2a208 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)this_2(D)]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)this_2(D)]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1554_55
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct basic_string * *)vectp.1554_55] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb7
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _68 = operator new (_62);
/usr/include/c++/13/bits/char_traits.h:399:25: missed: statement clobbers memory: _46 = __builtin_strlen (_36);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _68 = operator new (_62);
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at dominance boundary bb13
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at dominance boundary bb17
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb18
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_112, _36, _46);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at loop 2 exit at bb38
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at dominance boundary bb19
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at dominance boundary bb32
/usr/include/c++/13/bits/stl_vector.h:713:2: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:713:2: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:713:2: missed: splitting region at dominance boundary bb9
/usr/include/c++/13/bits/stl_vector.h:713:2: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:713:2: missed: splitting region at dominance boundary bb21
/usr/include/c++/13/bits/basic_string.h:646:28: missed: not vectorized: statement can throw an exception: std::__throw_logic_error ("basic_string: construction from null is not valid");
/usr/include/c++/13/bits/basic_string.h:646:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:646:28: missed: splitting region at dominance boundary bb3
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: _41 = __builtin_eh_pointer (7);
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_begin_catch (_41);
/usr/include/c++/13/bits/stl_uninitialized.h:126:4: missed: not vectorized: statement can throw an exception: __cxa_rethrow ();
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_end_catch ();
/usr/include/c++/13/bits/stl_vector.h:707:2: missed: not vectorized: statement can throw an exception: resx 6
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (__first_42);
/usr/include/c++/13/bits/stl_construct.h:162:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:162:4: missed: splitting region at dominance boundary bb28
/usr/include/c++/13/bits/stl_vector.h:1910:24: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("cannot create std::vector larger than max_size()");
/usr/include/c++/13/bits/stl_vector.h:1910:24: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_8, _69);
/usr/include/c++/13/bits/stl_vector.h:371:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:371:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
Water_vectorised_SIMD.cpp:346:26: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:346:26: missed: not vectorized: latch block not empty.
Water_vectorised_SIMD.cpp:341:68: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:341:68: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_uninitialized.h:642:19: optimized: loop vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:109:7: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:109:7: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1711 = *__first$_M_current_1709;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1905 = *__first$_M_current_1721;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2005 = *__first$_M_current_1716;
Water_vectorised_SIMD.cpp:109:7: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:109:7: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1883 = *__first$_M_current_2379;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1880 = *__first$_M_current_2365;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_646 = *__first$_M_current_2361;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2351 = *__first$_M_current_73;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2349 = *__first$_M_current_2346;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2345 = *__first$_M_current_1874;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2339 = *__first$_M_current_2338;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_63 = *__first$_M_current_62;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1857 = *__first$_M_current_2507;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1816 = *__first$_M_current_2584;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_97 = *__first$_M_current_194;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_213 = *__first$_M_current_1818;
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:324:8: note: vectorized 10 loops in function.
Water_vectorised_SIMD.cpp:324:8: missed: splitting region at control altering definition _311 = operator new (_310);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _311 = operator new (_310);
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:398:25: note: SLPing BB part
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x2d1c088 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&O + 49] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x2d1c108
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 79, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
Water_vectorised_SIMD.cpp:119:7: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:119:7: note: node 0x2d1c188 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:119:7: note: op template: O.mass = 1.6e+1;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 0 O.mass = 1.6e+1;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 1 O.ep = 6.5000000000000002220446049250313080847263336181640625e-1;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 2 O.sigma = 3.09999999999999997779553950749686919152736663818359375e-1;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 3 O.charge = -8.1999999999999995115018691649311222136020660400390625e-1;
Water_vectorised_SIMD.cpp:119:7: note: 	children 0x2d1c208
Water_vectorised_SIMD.cpp:119:7: note: node (constant) 0x2d1c208 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:119:7: note: 	{ 1.6e+1, 6.5000000000000002220446049250313080847263336181640625e-1, 3.09999999999999997779553950749686919152736663818359375e-1, -8.1999999999999995115018691649311222136020660400390625e-1 }
Water_vectorised_SIMD.cpp:119:7: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 56
  Scalar cost: 64
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x2d1c288 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&D.168920 + 16] = 79;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&D.168920 + 16] = 79;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&D.168920 + 17] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x2d1c308
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x2d1c308 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 79, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c408 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c488
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c488 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c588 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&O + 64B].D.162866._M_impl.D.162204._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 2 MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.162204._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 3 MEM[(struct _Vector_base *)&O + 88B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 4 MEM[(struct vector *)&O + 88B].D.162866._M_impl.D.162204._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 5 MEM[(struct _Vector_base *)&O + 88B]._M_impl.D.162204._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B, 0B, 0B, 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis for part in loop 0:
  Vector cost: 60
  Scalar cost: 96
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c088 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&O + 49] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 79, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&O + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&O + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&O + 48] = { 79, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c188 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: O.mass = 1.6e+1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 O.mass = 1.6e+1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 O.ep = 6.5000000000000002220446049250313080847263336181640625e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 2 O.sigma = 3.09999999999999997779553950749686919152736663818359375e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 3 O.charge = -8.1999999999999995115018691649311222136020660400390625e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c208
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c208 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 1.6e+1, 6.5000000000000002220446049250313080847263336181640625e-1, 3.09999999999999997779553950749686919152736663818359375e-1, -8.1999999999999995115018691649311222136020660400390625e-1 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: O.mass = 1.6e+1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 6.5000000000000002220446049250313080847263336181640625e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 3.09999999999999997779553950749686919152736663818359375e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand -8.1999999999999995115018691649311222136020660400390625e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: O.mass
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &O
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) double> [(double *)&O] = { 1.6e+1, 6.5000000000000002220446049250313080847263336181640625e-1 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) double> [(double *)&O + 16B] = { 3.09999999999999997779553950749686919152736663818359375e-1, -8.1999999999999995115018691649311222136020660400390625e-1 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c288 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&D.168920 + 16] = 79;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&D.168920 + 16] = 79;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&D.168920 + 17] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c308
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c308 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 79, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&D.168920 + 16] = 79;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&D.168920 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&D.168920 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&D.168920 + 16] = { 79, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c408 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c488
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c488 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&O + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_impl_data *)&O + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c588 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&O + 64B].D.162866._M_impl.D.162204._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 2 MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.162204._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 3 MEM[(struct _Vector_base *)&O + 88B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 4 MEM[(struct vector *)&O + 88B].D.162866._M_impl.D.162204._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 5 MEM[(struct _Vector_base *)&O + 88B]._M_impl.D.162204._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B, 0B, 0B, 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.162204._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_base *)&O + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 80B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 96B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at dominance boundary bb8
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at control altering definition _2275 = operator new (_310);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _2275 = operator new (_310);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_688->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_688->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_688->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c408
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c408 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c288 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c308
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c308 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_688->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_688->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_688->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c408
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c408 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_688->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_688->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1732_911
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1732_911] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c288 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c308
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c308 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&O + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&O + 88B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 88B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb11
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _223 = operator new (_310);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _223 = operator new (_310);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c308 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_813->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_813->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_813->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c588 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c488
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c488 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c308 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_813->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_813->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_813->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_813->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_813->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1736_951
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1736_951] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c588 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c488
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c488 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&O + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&O + 112B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 112B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb23
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_239, _346);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 86
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb14
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_245, _347);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 85
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb17
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_construct.h:119:7: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c488 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_948->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_948->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_948->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c308
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c308 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c488 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_948->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_948->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_948->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c308
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c308 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ------>vectorizing SLP node starting from: __cur_948->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_construct.h:119:7: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_construct.h:119:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_948->x
/usr/include/c++/13/bits/stl_construct.h:119:7: note: created vectp.1740_1079
/usr/include/c++/13/bits/stl_construct.h:119:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1740_1079] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_construct.h:119:7: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: splitting region at control altering definition _332 = operator new (_2828);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_2318, _355);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _332 = operator new (_2828);
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:398:25: note: SLPing BB part
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x2d1c488 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&H1 + 49] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x2d1c308
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x2d1c308 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 72, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
Water_vectorised_SIMD.cpp:119:7: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:119:7: note: node 0x2d1c588 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:119:7: note: op template: H1.mass = 1.0e+0;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 0 H1.mass = 1.0e+0;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 1 H1.ep = 1.882800000000000029132252166164107620716094970703125e-1;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 2 H1.sigma = 2.37999999999999989341858963598497211933135986328125e-1;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 3 H1.charge = 4.09999999999999975575093458246556110680103302001953125e-1;
Water_vectorised_SIMD.cpp:119:7: note: 	children 0x2d1c608
Water_vectorised_SIMD.cpp:119:7: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:119:7: note: 	{ 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 }
Water_vectorised_SIMD.cpp:119:7: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 56
  Scalar cost: 64
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c408 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c188
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c188 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&D.168938 + 16] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&D.168938 + 16] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&D.168938 + 17] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x2d1c088
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x2d1c088 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 72, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&H1 + 64B].D.162866._M_impl.D.162204._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c488 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&H1 + 49] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c308
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c308 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 72, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&H1 + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&H1 + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&H1 + 48] = { 72, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c588 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: H1.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 H1.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 H1.ep = 1.882800000000000029132252166164107620716094970703125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 2 H1.sigma = 2.37999999999999989341858963598497211933135986328125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 3 H1.charge = 4.09999999999999975575093458246556110680103302001953125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: H1.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 1.882800000000000029132252166164107620716094970703125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 2.37999999999999989341858963598497211933135986328125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 4.09999999999999975575093458246556110680103302001953125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: H1.mass
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &H1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) double> [(double *)&H1] = { 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) double> [(double *)&H1 + 16B] = { 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c408 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c188
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c188 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_impl_data *)&H1 + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H1 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&D.168938 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&D.168938 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&D.168938 + 17] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c088
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c088 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 72, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&D.168938 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&D.168938 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&D.168938 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&D.168938 + 16] = { 72, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&H1 + 64B].D.162866._M_impl.D.162204._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.162204._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_base *)&H1 + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H1 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at dominance boundary bb33
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at control altering definition _1865 = operator new (_2828);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1865 = operator new (_2828);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1073->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1073->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1073->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c208
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c208 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c408 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c188
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c188 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_1073->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_1073->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_1073->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c208
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c208 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_1073->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1073->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1752_1277
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1752_1277] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c408 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c188
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c188 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&H1 + 88B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H1 + 88B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb36
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _1894 = operator new (_2828);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1894 = operator new (_2828);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c188 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1162->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1162->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1162->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c088
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c088 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c188 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_1162->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_1162->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_1162->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_1162->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1162->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1756_1372
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1756_1372] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c088
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c088 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&H1 + 112B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H1 + 112B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb48
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_387, _470);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 89
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb53
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_393, _471);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 88
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb39
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&H1.name);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 87
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&D.168938);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 14
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb42
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_construct.h:119:7: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c088 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1273->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1273->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1273->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c188
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c188 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c088 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1273->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1273->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1273->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c188
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c188 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ------>vectorizing SLP node starting from: __cur_1273->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_construct.h:119:7: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_construct.h:119:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1273->x
/usr/include/c++/13/bits/stl_construct.h:119:7: note: created vectp.1760_1504
/usr/include/c++/13/bits/stl_construct.h:119:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1760_1504] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_construct.h:119:7: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: splitting region at control altering definition _2064 = operator new (_2828);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_2265, _479);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _2064 = operator new (_2828);
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:398:25: note: SLPing BB part
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x2d1c088 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&H2 + 49] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x2d1c188
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x2d1c188 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 72, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
Water_vectorised_SIMD.cpp:119:7: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:119:7: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:119:7: note: op template: H2.mass = 1.0e+0;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 0 H2.mass = 1.0e+0;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 1 H2.ep = 1.882800000000000029132252166164107620716094970703125e-1;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 2 H2.sigma = 2.37999999999999989341858963598497211933135986328125e-1;
Water_vectorised_SIMD.cpp:119:7: note: 	stmt 3 H2.charge = 4.09999999999999975575093458246556110680103302001953125e-1;
Water_vectorised_SIMD.cpp:119:7: note: 	children 0x2d1c388
Water_vectorised_SIMD.cpp:119:7: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:119:7: note: 	{ 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 }
Water_vectorised_SIMD.cpp:119:7: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 56
  Scalar cost: 64
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c588
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&D.168941 + 16] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&D.168941 + 16] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&D.168941 + 17] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x2d1c488
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x2d1c488 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 72, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&H2 + 64B].D.162866._M_impl.D.162204._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c688
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c688 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c088 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&H2 + 49] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c188
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c188 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 72, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&H2 + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&H2 + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&H2 + 48] = { 72, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: H2.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 H2.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 H2.ep = 1.882800000000000029132252166164107620716094970703125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 2 H2.sigma = 2.37999999999999989341858963598497211933135986328125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 3 H2.charge = 4.09999999999999975575093458246556110680103302001953125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: H2.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 1.882800000000000029132252166164107620716094970703125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 2.37999999999999989341858963598497211933135986328125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 4.09999999999999975575093458246556110680103302001953125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: H2.mass
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &H2
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) double> [(double *)&H2] = { 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) double> [(double *)&H2 + 16B] = { 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c588
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_impl_data *)&H2 + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H2 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&D.168941 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&D.168941 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&D.168941 + 17] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c488
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c488 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 72, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&D.168941 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&D.168941 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&D.168941 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&D.168941 + 16] = { 72, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&H2 + 64B].D.162866._M_impl.D.162204._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c688
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x2d1c688 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.162204._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.162204._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_base *)&H2 + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H2 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at dominance boundary bb58
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at control altering definition _2183 = operator new (_2828);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _2183 = operator new (_2828);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c688 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1377->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1377->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1377->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c588
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c688 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_1377->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_1377->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_1377->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_1377->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1377->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1772_1767
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1772_1767] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c588
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&H2 + 88B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H2 + 88B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb61
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _2291 = operator new (_2828);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _2291 = operator new (_2828);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c588 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1526->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1526->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1526->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c688
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c688 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c488
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c488 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c588 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_1526->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_1526->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_1526->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c688
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c688 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_1526->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1526->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1776_1826
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1776_1826] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c488
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c488 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&H2 + 112B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H2 + 112B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb73
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_511, _594);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 92
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb78
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_517, _595);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 91
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb64
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&H2.name);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 90
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&D.168941);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 23
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb67
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_construct.h:119:7: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c488 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1675->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1675->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1675->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c588
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x2d1c488 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1675->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1675->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1675->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x2d1c588
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ------>vectorizing SLP node starting from: __cur_1675->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_construct.h:119:7: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_construct.h:119:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1675->x
/usr/include/c++/13/bits/stl_construct.h:119:7: note: created vectp.1780_1949
/usr/include/c++/13/bits/stl_construct.h:119:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1780_1949] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_construct.h:119:7: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: splitting region at control altering definition _627 = operator new (64);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_2257, _610);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _627 = operator new (64);
Water_vectorised_SIMD.cpp:335:5: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:335:5: note: SLPing BB part
Water_vectorised_SIMD.cpp:335:5: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:335:5: note: node 0x2d1c488 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:335:5: note: op template: D.168954[0].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 0 D.168954[0].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 1 D.168954[0].L0 = 9.583999999999999463984323710974422283470630645751953125e-2;
Water_vectorised_SIMD.cpp:335:5: note: 	children 0x2d1c588
Water_vectorised_SIMD.cpp:335:5: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:335:5: note: 	{ 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 }
Water_vectorised_SIMD.cpp:335:5: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:335:5: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
Water_vectorised_SIMD.cpp:335:5: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:335:5: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:335:5: note: op template: D.168954[0].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 0 D.168954[0].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 1 D.168954[0].a2 = 1;
Water_vectorised_SIMD.cpp:335:5: note: 	children 0x2d1c688
Water_vectorised_SIMD.cpp:335:5: note: node (constant) 0x2d1c688 (max_nunits=1, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:335:5: note: 	{ 0, 1 }
Water_vectorised_SIMD.cpp:335:5: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:335:5: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
Water_vectorised_SIMD.cpp:335:5: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:335:5: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:335:5: note: op template: D.168954[1].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 0 D.168954[1].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 1 D.168954[1].L0 = 9.583999999999999463984323710974422283470630645751953125e-2;
Water_vectorised_SIMD.cpp:335:5: note: 	children 0x2d1c608
Water_vectorised_SIMD.cpp:335:5: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:335:5: note: 	{ 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 }
Water_vectorised_SIMD.cpp:335:5: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:335:5: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
Water_vectorised_SIMD.cpp:335:5: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:335:5: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:335:5: note: op template: D.168954[1].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 0 D.168954[1].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 1 D.168954[1].a2 = 2;
Water_vectorised_SIMD.cpp:335:5: note: 	children 0x2d1c388
Water_vectorised_SIMD.cpp:335:5: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:335:5: note: 	{ 0, 2 }
Water_vectorised_SIMD.cpp:335:5: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:335:5: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
Water_vectorised_SIMD.cpp:335:5: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:335:5: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:335:5: note: node 0x2d1c488 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:335:5: note: op template: D.168954[0].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 0 D.168954[0].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 1 D.168954[0].L0 = 9.583999999999999463984323710974422283470630645751953125e-2;
Water_vectorised_SIMD.cpp:335:5: note: 	children 0x2d1c588
Water_vectorised_SIMD.cpp:335:5: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:335:5: note: 	{ 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 }
Water_vectorised_SIMD.cpp:335:5: note: ------>vectorizing SLP node starting from: D.168954[0].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: vect_is_simple_use: operand 9.583999999999999463984323710974422283470630645751953125e-2, type of def: constant
Water_vectorised_SIMD.cpp:335:5: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:335:5: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: D.168954[0].K
Water_vectorised_SIMD.cpp:335:5: note: created &D.168954[0]
Water_vectorised_SIMD.cpp:335:5: note: add new stmt: MEM <vector(2) double> [(double *)&D.168954] = { 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 };
Water_vectorised_SIMD.cpp:335:5: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:335:5: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:335:5: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:335:5: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:335:5: note: op template: D.168954[0].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 0 D.168954[0].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 1 D.168954[0].a2 = 1;
Water_vectorised_SIMD.cpp:335:5: note: 	children 0x2d1c688
Water_vectorised_SIMD.cpp:335:5: note: node (constant) 0x2d1c688 (max_nunits=1, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:335:5: note: 	{ 0, 1 }
Water_vectorised_SIMD.cpp:335:5: note: ------>vectorizing SLP node starting from: D.168954[0].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: vect_is_simple_use: operand 1, type of def: constant
Water_vectorised_SIMD.cpp:335:5: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:335:5: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: D.168954[0].a1
Water_vectorised_SIMD.cpp:335:5: note: created &D.168954[0].a1
Water_vectorised_SIMD.cpp:335:5: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int *)&D.168954 + 16B] = { 0, 1 };
Water_vectorised_SIMD.cpp:335:5: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:335:5: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:335:5: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:335:5: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:335:5: note: op template: D.168954[1].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 0 D.168954[1].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 1 D.168954[1].L0 = 9.583999999999999463984323710974422283470630645751953125e-2;
Water_vectorised_SIMD.cpp:335:5: note: 	children 0x2d1c608
Water_vectorised_SIMD.cpp:335:5: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:335:5: note: 	{ 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 }
Water_vectorised_SIMD.cpp:335:5: note: ------>vectorizing SLP node starting from: D.168954[1].K = 2.0e+4;
Water_vectorised_SIMD.cpp:335:5: note: vect_is_simple_use: operand 9.583999999999999463984323710974422283470630645751953125e-2, type of def: constant
Water_vectorised_SIMD.cpp:335:5: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:335:5: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: D.168954[1].K
Water_vectorised_SIMD.cpp:335:5: note: created &D.168954[1]
Water_vectorised_SIMD.cpp:335:5: note: add new stmt: MEM <vector(2) double> [(double *)&D.168954 + 32B] = { 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 };
Water_vectorised_SIMD.cpp:335:5: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:335:5: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:335:5: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:335:5: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:335:5: note: op template: D.168954[1].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 0 D.168954[1].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: 	stmt 1 D.168954[1].a2 = 2;
Water_vectorised_SIMD.cpp:335:5: note: 	children 0x2d1c388
Water_vectorised_SIMD.cpp:335:5: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:335:5: note: 	{ 0, 2 }
Water_vectorised_SIMD.cpp:335:5: note: ------>vectorizing SLP node starting from: D.168954[1].a1 = 0;
Water_vectorised_SIMD.cpp:335:5: note: vect_is_simple_use: operand 2, type of def: constant
Water_vectorised_SIMD.cpp:335:5: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:335:5: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: D.168954[1].a1
Water_vectorised_SIMD.cpp:335:5: note: created &D.168954[1].a1
Water_vectorised_SIMD.cpp:335:5: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int *)&D.168954 + 48B] = { 0, 2 };
Water_vectorised_SIMD.cpp:335:5: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:335:5: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:335:5: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:335:5: missed: splitting region at dominance boundary bb81
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 93
Water_vectorised_SIMD.cpp:335:5: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:335:5: missed: splitting region at control altering definition _654 = operator new (40);
/usr/include/c++/13/bits/stl_algobase.h:437:23: missed: statement clobbers memory: __builtin_memcpy (_627, &D.168954, 64);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _654 = operator new (40);
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at dominance boundary bb83
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 94
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at control altering definition _675 = operator new (40);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _675 = operator new (40);
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ***** Analysis succeeded with vector mode V2DF
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: _654->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 _654->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 _654->Phi0 = 1.8229964037080772509824555527302436530590057373046875e+0;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ 1.0e+3, 1.8229964037080772509824555527302436530590057373046875e+0 }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: _654->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 _654->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 _654->a2 = 0;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ 1, 0 }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: _654->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 _654->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 _654->Phi0 = 1.8229964037080772509824555527302436530590057373046875e+0;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ 1.0e+3, 1.8229964037080772509824555527302436530590057373046875e+0 }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ------>vectorizing SLP node starting from: _654->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vect_is_simple_use: operand 1.8229964037080772509824555527302436530590057373046875e+0, type of def: constant
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: _654->K
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: created vectp.1790_1973
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1790_1973] = { 1.0e+3, 1.8229964037080772509824555527302436530590057373046875e+0 };
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_algobase.h:398:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: _654->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 _654->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 _654->a2 = 0;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ 1, 0 }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ------>vectorizing SLP node starting from: _654->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: _654->a1
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: created vectp.1792_1096
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int *)vectp.1792_1096] = { 1, 0 };
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_algobase.h:398:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_algobase.h:398:4: missed: splitting region at dominance boundary bb85
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_algobase.h:398:4: missed: splitting region at control altering definition _710 = operator new (64);
/usr/include/c++/13/bits/stl_algobase.h:398:4: missed: not vectorized: more than one data ref in stmt: *_675 = MEM[(const struct Angle &)_654];
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _710 = operator new (64);
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at dominance boundary bb86
/usr/include/c++/13/bits/new_allocator.h:151:48: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: splitting region at control altering definition _2313 = operator new (_752);
/usr/include/c++/13/bits/stl_algobase.h:437:23: missed: statement clobbers memory: __builtin_memcpy (_710, _627, 64);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _2313 = operator new (_752);
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis succeeded with vector mode V2DF
Water_vectorised_SIMD.cpp:109:7: note: SLPing BB part
Water_vectorised_SIMD.cpp:109:7: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.169003].mass = _711;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.169003].mass = _711;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.169003].ep = _712;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.169003].sigma = _713;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.169003].charge = _714;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c108
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c108 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _711 = MEM[(const struct Atoms &)&O].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _711 = MEM[(const struct Atoms &)&O].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _712 = MEM[(const struct Atoms &)&O].ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _713 = MEM[(const struct Atoms &)&O].sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _714 = MEM[(const struct Atoms &)&O].charge;
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis for part in loop 0:
  Vector cost: 56
  Scalar cost: 112
Water_vectorised_SIMD.cpp:109:7: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:109:7: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.169003].mass = _711;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.169003].mass = _711;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.169003].ep = _712;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.169003].sigma = _713;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.169003].charge = _714;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c108
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c108 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _711 = MEM[(const struct Atoms &)&O].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _711 = MEM[(const struct Atoms &)&O].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _712 = MEM[(const struct Atoms &)&O].ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _713 = MEM[(const struct Atoms &)&O].sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _714 = MEM[(const struct Atoms &)&O].charge;
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: _711 = MEM[(const struct Atoms &)&O].mass;
Water_vectorised_SIMD.cpp:109:7: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Atoms &)&O].mass
Water_vectorised_SIMD.cpp:109:7: note: created &MEM[(const struct Atoms &)&O]
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__711.1795_1975 = MEM <const vector(2) double> [(double *)&O];
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__711.1796_1305 = MEM <const vector(2) double> [(double *)&O + 16B];
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: MEM[(struct Atoms *)&D.169003].mass = _711;
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&O].mass, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&O].ep, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&O].sigma, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&O].charge, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Atoms *)&D.169003].mass
Water_vectorised_SIMD.cpp:109:7: note: created &MEM[(struct Atoms *)&D.169003]
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)&D.169003] = vect__711.1795_1975;
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)&D.169003 + 16B] = vect__711.1796_1305;
Water_vectorised_SIMD.cpp:109:7: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:109:7: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:109:7: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb94
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb98
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb99
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_787, _717, _718);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _782 = operator new (_1325);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _782 = operator new (_1325);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169003 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169003 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169003 + 64B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.169003 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb105
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb106
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _806 = operator new (_1416);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_213 = *__first$_M_current_1818;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _806 = operator new (_1416);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169003 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169003 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169003 + 88B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.169003 + 88B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb113
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb114
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _830 = operator new (_1415);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_97 = *__first$_M_current_194;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _830 = operator new (_1415);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169003 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169003 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169003 + 112B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.169003 + 112B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb121
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb122
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _880 = operator new (_874);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1816 = *__first$_M_current_2584;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _880 = operator new (_874);
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:109:7: note: SLPing BB part
Water_vectorised_SIMD.cpp:109:7: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.169003 + 136B].mass = _833;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.169003 + 136B].mass = _833;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.169003 + 136B].ep = _834;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.169003 + 136B].sigma = _835;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.169003 + 136B].charge = _836;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c108
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c108 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _833 = MEM[(const struct Atoms &)&H1].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _833 = MEM[(const struct Atoms &)&H1].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _834 = MEM[(const struct Atoms &)&H1].ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _835 = MEM[(const struct Atoms &)&H1].sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _836 = MEM[(const struct Atoms &)&H1].charge;
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis for part in loop 0:
  Vector cost: 56
  Scalar cost: 112
Water_vectorised_SIMD.cpp:109:7: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:109:7: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.169003 + 136B].mass = _833;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.169003 + 136B].mass = _833;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.169003 + 136B].ep = _834;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.169003 + 136B].sigma = _835;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.169003 + 136B].charge = _836;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c108
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c108 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _833 = MEM[(const struct Atoms &)&H1].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _833 = MEM[(const struct Atoms &)&H1].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _834 = MEM[(const struct Atoms &)&H1].ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _835 = MEM[(const struct Atoms &)&H1].sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _836 = MEM[(const struct Atoms &)&H1].charge;
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: _833 = MEM[(const struct Atoms &)&H1].mass;
Water_vectorised_SIMD.cpp:109:7: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Atoms &)&H1].mass
Water_vectorised_SIMD.cpp:109:7: note: created &MEM[(const struct Atoms &)&H1]
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__833.1807_1988 = MEM <const vector(2) double> [(double *)&H1];
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__833.1808_1866 = MEM <const vector(2) double> [(double *)&H1 + 16B];
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: MEM[(struct Atoms *)&D.169003 + 136B].mass = _833;
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H1].mass, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H1].ep, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H1].sigma, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H1].charge, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Atoms *)&D.169003 + 136B].mass
Water_vectorised_SIMD.cpp:109:7: note: created &MEM[(struct Atoms *)&D.169003 + 136B]
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)&D.169003 + 136B] = vect__833.1807_1988;
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)&D.169003 + 152B] = vect__833.1808_1866;
Water_vectorised_SIMD.cpp:109:7: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:109:7: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:109:7: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb146
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb150
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb151
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_1844, _839, _840);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _904 = operator new (_3132);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _904 = operator new (_3132);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 200B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 200B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169003 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169003 + 200B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169003 + 200B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.169003 + 200B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb157
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb158
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _928 = operator new (_1428);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1857 = *__first$_M_current_2507;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _928 = operator new (_1428);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 224B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 224B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169003 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169003 + 224B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169003 + 224B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.169003 + 224B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb165
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb166
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _952 = operator new (_1433);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_63 = *__first$_M_current_62;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _952 = operator new (_1433);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 248B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 248B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169003 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169003 + 248B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169003 + 248B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.169003 + 248B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb173
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb174
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1002 = operator new (_996);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2339 = *__first$_M_current_2338;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1002 = operator new (_996);
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:109:7: note: SLPing BB part
Water_vectorised_SIMD.cpp:109:7: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.169003 + 272B].mass = _955;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.169003 + 272B].mass = _955;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.169003 + 272B].ep = _956;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.169003 + 272B].sigma = _957;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.169003 + 272B].charge = _958;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c108
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c108 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _955 = MEM[(const struct Atoms &)&H2].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _955 = MEM[(const struct Atoms &)&H2].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _956 = MEM[(const struct Atoms &)&H2].ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _957 = MEM[(const struct Atoms &)&H2].sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _958 = MEM[(const struct Atoms &)&H2].charge;
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis for part in loop 0:
  Vector cost: 56
  Scalar cost: 112
Water_vectorised_SIMD.cpp:109:7: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:109:7: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.169003 + 272B].mass = _955;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.169003 + 272B].mass = _955;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.169003 + 272B].ep = _956;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.169003 + 272B].sigma = _957;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.169003 + 272B].charge = _958;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c108
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c108 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _955 = MEM[(const struct Atoms &)&H2].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _955 = MEM[(const struct Atoms &)&H2].mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _956 = MEM[(const struct Atoms &)&H2].ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _957 = MEM[(const struct Atoms &)&H2].sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _958 = MEM[(const struct Atoms &)&H2].charge;
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: _955 = MEM[(const struct Atoms &)&H2].mass;
Water_vectorised_SIMD.cpp:109:7: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Atoms &)&H2].mass
Water_vectorised_SIMD.cpp:109:7: note: created &MEM[(const struct Atoms &)&H2]
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__955.1819_1864 = MEM <const vector(2) double> [(double *)&H2];
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__955.1820_1832 = MEM <const vector(2) double> [(double *)&H2 + 16B];
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: MEM[(struct Atoms *)&D.169003 + 272B].mass = _955;
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H2].mass, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H2].ep, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H2].sigma, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H2].charge, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Atoms *)&D.169003 + 272B].mass
Water_vectorised_SIMD.cpp:109:7: note: created &MEM[(struct Atoms *)&D.169003 + 272B]
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)&D.169003 + 272B] = vect__955.1819_1864;
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)&D.169003 + 288B] = vect__955.1820_1832;
Water_vectorised_SIMD.cpp:109:7: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:109:7: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:109:7: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb198
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb202
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb203
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_1723, _961, _962);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _1026 = operator new (_3128);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1026 = operator new (_3128);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 336B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 336B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169003 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169003 + 336B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169003 + 336B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.169003 + 336B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb209
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb210
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1050 = operator new (_1431);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2345 = *__first$_M_current_1874;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1050 = operator new (_1431);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 360B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 360B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169003 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169003 + 360B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169003 + 360B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.169003 + 360B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb217
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb218
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1074 = operator new (_1430);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2349 = *__first$_M_current_2346;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1074 = operator new (_1430);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 384B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169003 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169003 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169003 + 384B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169003 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169003 + 384B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169003 + 384B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.169003 + 384B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb225
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb226
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1100 = operator new (408);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2351 = *__first$_M_current_73;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1100 = operator new (408);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169017]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169017]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169017]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.169017]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.169017]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.169017]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.169017]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.169017]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.169017]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Atoms * *)&D.169017] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb242
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _1157 = operator new (_1151);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1157 = operator new (_1151);
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:109:7: note: SLPing BB part
Water_vectorised_SIMD.cpp:109:7: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: *__cur_2355.mass = _1110;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 *__cur_2355.mass = _1110;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 *__cur_2355.ep = _1111;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 *__cur_2355.sigma = _1112;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 *__cur_2355.charge = _1113;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c508
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c508 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _1110 = *__first_1878.mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _1110 = *__first_1878.mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _1111 = *__first_1878.ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _1112 = *__first_1878.sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _1113 = *__first_1878.charge;
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis for part in loop 24:
  Vector cost: 56
  Scalar cost: 112
Water_vectorised_SIMD.cpp:109:7: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:109:7: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: *__cur_2355.mass = _1110;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 *__cur_2355.mass = _1110;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 *__cur_2355.ep = _1111;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 *__cur_2355.sigma = _1112;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 *__cur_2355.charge = _1113;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c508
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c508 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _1110 = *__first_1878.mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _1110 = *__first_1878.mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _1111 = *__first_1878.ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _1112 = *__first_1878.sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _1113 = *__first_1878.charge;
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: _1110 = *__first_1878.mass;
Water_vectorised_SIMD.cpp:109:7: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: *__first_1878.mass
Water_vectorised_SIMD.cpp:109:7: note: created vectp.1832_730
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__1110.1833_735 = MEM <const vector(2) double> [(double *)vectp.1832_730];
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vectp.1832_852 = vectp.1832_730 + 16;
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__1110.1834_857 = MEM <const vector(2) double> [(double *)vectp.1832_852];
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: *__cur_2355.mass = _1110;
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand *__first_1878.mass, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand *__first_1878.ep, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand *__first_1878.sigma, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand *__first_1878.charge, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *__cur_2355.mass
Water_vectorised_SIMD.cpp:109:7: note: created vectp.1836_858
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1836_858] = vect__1110.1833_735;
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vectp.1836_986 = vectp.1836_858 + 16;
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1836_986] = vect__1110.1834_857;
Water_vectorised_SIMD.cpp:109:7: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:109:7: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:109:7: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb251
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb255
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb256
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_2007, _1116, _1117);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _1181 = operator new (_483);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1181 = operator new (_483);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_2355 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_2355 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_2355 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 24:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_2355 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_2355 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_2355 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_2355 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_2355 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1838_1088
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1838_1088] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb265
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb266
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1205 = operator new (_3119);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_646 = *__first$_M_current_2361;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1205 = operator new (_3119);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_2355 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_2355 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_2355 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 24:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_2355 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_2355 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_2355 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_2355 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_2355 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1840_1093
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1840_1093] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb276
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb277
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1229 = operator new (_1414);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1880 = *__first$_M_current_2365;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1229 = operator new (_1414);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_2355 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_2355 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_2355 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 24:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c108 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_2355 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_2355 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_2355 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c508
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c508 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_2355 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_2355 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1842_1186
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1842_1186] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb287
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb288
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at loop 24 exit at bb304
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1883 = *__first$_M_current_2379;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at control altering definition _1274 = operator new (_1413);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1274 = operator new (_1413);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c508 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&mols]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&mols]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Atoms * *)&mols] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb320
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _1333 = operator new (_1327);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1333 = operator new (_1327);
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis succeeded with vector mode V2DI
Water_vectorised_SIMD.cpp:109:7: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&mols]._M_impl.D.163340._M_start = iftmp.127_1267;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&mols]._M_impl.D.163340._M_start = iftmp.127_1267;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct _Vector_base *)&mols]._M_impl.D.163340._M_finish = iftmp.127_1267;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (external) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ iftmp.127_1267, iftmp.127_1267 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis for part in loop 0:
  Vector cost: 20
  Scalar cost: 32
Water_vectorised_SIMD.cpp:109:7: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: *__cur_1891.mass = _1286;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 *__cur_1891.mass = _1286;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 *__cur_1891.ep = _1287;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 *__cur_1891.sigma = _1288;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 *__cur_1891.charge = _1289;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c208
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c208 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _1286 = *__first$_M_current_2430.mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _1286 = *__first$_M_current_2430.mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _1287 = *__first$_M_current_2430.ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _1288 = *__first$_M_current_2430.sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _1289 = *__first$_M_current_2430.charge;
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:109:7: note: Cost model analysis for part in loop 29:
  Vector cost: 56
  Scalar cost: 112
Water_vectorised_SIMD.cpp:109:7: note: Basic block will be vectorized using SLP
Water_vectorised_SIMD.cpp:109:7: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:109:7: note: op template: MEM[(struct _Vector_base *)&mols]._M_impl.D.163340._M_start = iftmp.127_1267;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 MEM[(struct _Vector_base *)&mols]._M_impl.D.163340._M_start = iftmp.127_1267;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 MEM[(struct _Vector_base *)&mols]._M_impl.D.163340._M_finish = iftmp.127_1267;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c108
Water_vectorised_SIMD.cpp:109:7: note: node (external) 0x2d1c108 (max_nunits=1, refcnt=1) vector(2) long unsigned int
Water_vectorised_SIMD.cpp:109:7: note: 	{ iftmp.127_1267, iftmp.127_1267 }
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_base *)&mols]._M_impl.D.163340._M_start = iftmp.127_1267;
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand iftmp.127_1267 = PHI <0B(304), _1274(318)>, type of def: external
Water_vectorised_SIMD.cpp:109:7: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_base *)&mols]._M_impl.D.163340._M_start
Water_vectorised_SIMD.cpp:109:7: note: created &MEM[(struct _Vector_base *)&mols]
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Atoms * *)&mols] = _1402;
Water_vectorised_SIMD.cpp:109:7: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:109:7: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:109:7: note: Vectorizing SLP tree:
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: *__cur_1891.mass = _1286;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 *__cur_1891.mass = _1286;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 *__cur_1891.ep = _1287;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 *__cur_1891.sigma = _1288;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 *__cur_1891.charge = _1289;
Water_vectorised_SIMD.cpp:109:7: note: 	children 0x2d1c208
Water_vectorised_SIMD.cpp:109:7: note: node 0x2d1c208 (max_nunits=2, refcnt=1) const vector(2) double
Water_vectorised_SIMD.cpp:109:7: note: op template: _1286 = *__first$_M_current_2430.mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 0 _1286 = *__first$_M_current_2430.mass;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 1 _1287 = *__first$_M_current_2430.ep;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 2 _1288 = *__first$_M_current_2430.sigma;
Water_vectorised_SIMD.cpp:109:7: note: 	stmt 3 _1289 = *__first$_M_current_2430.charge;
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: _1286 = *__first$_M_current_2430.mass;
Water_vectorised_SIMD.cpp:109:7: note: transform load. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: *__first$_M_current_2430.mass
Water_vectorised_SIMD.cpp:109:7: note: created vectp.1848_1427
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__1286.1849_1539 = MEM <const vector(2) double> [(double *)vectp.1848_1427];
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vectp.1848_1546 = vectp.1848_1427 + 16;
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vect__1286.1850_1549 = MEM <const vector(2) double> [(double *)vectp.1848_1546];
Water_vectorised_SIMD.cpp:109:7: note: ------>vectorizing SLP node starting from: *__cur_1891.mass = _1286;
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand *__first$_M_current_2430.mass, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand *__first$_M_current_2430.ep, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand *__first$_M_current_2430.sigma, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: vect_is_simple_use: operand *__first$_M_current_2430.charge, type of def: internal
Water_vectorised_SIMD.cpp:109:7: note: transform store. ncopies = 1
Water_vectorised_SIMD.cpp:109:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: *__cur_1891.mass
Water_vectorised_SIMD.cpp:109:7: note: created vectp.1852_1712
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1852_1712] = vect__1286.1849_1539;
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: vectp.1852_1729 = vectp.1852_1712 + 16;
Water_vectorised_SIMD.cpp:109:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1852_1729] = vect__1286.1850_1549;
Water_vectorised_SIMD.cpp:109:7: note: vectorizing stmts using SLP.
Water_vectorised_SIMD.cpp:109:7: optimized: basic block part vectorized using 16 byte vectors
Water_vectorised_SIMD.cpp:109:7: note: ***** The result for vector mode V16QI would be the same
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb329
Water_vectorised_SIMD.cpp:109:7: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:109:7: missed: splitting region at dominance boundary bb333
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb334
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_1694, _1292, _1293);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _1357 = operator new (_2244);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1357 = operator new (_2244);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1891 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1891 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1891 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 29:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1891 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1891 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1891 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_1891 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_1891 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1854_21
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1854_21] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb343
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb344
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1381 = operator new (_1412);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2005 = *__first$_M_current_1716;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1381 = operator new (_1412);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1891 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1891 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1891 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 29:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1891 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1891 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1891 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_1891 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_1891 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1856_299
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1856_299] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb354
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb355
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1405 = operator new (_1411);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1905 = *__first$_M_current_1721;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1405 = operator new (_1411);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1891 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1891 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1891 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c208
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c208 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 29:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1891 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1891 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1891 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c208
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c208 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_1891 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_1891 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1858_105
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1858_105] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb365
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb366
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at loop 29 exit at bb609
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1711 = *__first$_M_current_1709;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at dominance boundary bb382
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at control altering definition _1434 = operator new (64);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1434 = operator new (64);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 24B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 24B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&mols + 24B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Bond * *)&mols + 24B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb393
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _1454 = operator new (40);
/usr/include/c++/13/bits/stl_algobase.h:437:23: missed: statement clobbers memory: __builtin_memcpy (_1434, _710, 64);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1454 = operator new (40);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 48B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 48B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c388 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&mols + 48B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Angle * *)&mols + 48B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb394
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _70 = operator new (_2828);
/usr/include/c++/13/bits/stl_algobase.h:398:4: missed: not vectorized: more than one data ref in stmt: *_1454 = MEM[(const struct Angle &)_675];
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _70 = operator new (_2828);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 72B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c208
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c208 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 72B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c208
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c208 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&mols + 72B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct vector * *)&mols + 72B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb404
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1454, 40);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 113
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb407
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1434, 64);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 112
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb397
Water_vectorised_SIMD.cpp:134:6: missed: statement clobbers memory: std::vector<Atoms>::~vector (&mols.atoms);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 111
Water_vectorised_SIMD.cpp:134:6: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:134:6: missed: splitting region at dominance boundary bb399
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1797]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1797]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1797]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x2d1c208 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1797]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1797]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1797]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x2d1c608
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x2d1c608 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_1797]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_1797]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1866_2778
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int * *)vectp.1866_2778] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb511
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1494, _1512);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1500, _1513);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1506, _1514);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1515, _1519);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1100, 408);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1523, _1541);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1529, _1542);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1535, _1543);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1544, _1548);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_710, 64);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_675, 40);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_654, 40);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_627, 64);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1765, _1783);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1771, _1784);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1777, _1785);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1786, _1790);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1746, _1792);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1752, _1793);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1758, _1794);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1795, _1799);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1727, _1801);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1733, _1802);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1739, _1803);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1804, _1808);
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** Analysis succeeded with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:106:4: note: SLPing BB part
Water_vectorised_SIMD.cpp:356:28: note: Costing subgraph: 
Water_vectorised_SIMD.cpp:356:28: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: op template: _44->x = _17;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 0 _44->x = _17;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 1 _44->y = _18;
Water_vectorised_SIMD.cpp:356:28: note: 	children 0x2d1c388
Water_vectorised_SIMD.cpp:356:28: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: op template: _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 0 _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 1 _18 = _14 + 5.87079636588852260548065942202811129391193389892578125e-2;
Water_vectorised_SIMD.cpp:356:28: note: 	children 0x2d1c108 0x2d1c588
Water_vectorised_SIMD.cpp:356:28: note: node 0x2d1c108 (max_nunits=2, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: op template: _13 = radius_101 * x_119;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 0 _13 = radius_101 * x_119;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 1 _14 = radius_101 * y_116;
Water_vectorised_SIMD.cpp:356:28: note: 	children 0x2d1c508 0x2d1c488
Water_vectorised_SIMD.cpp:356:28: note: node (external) 0x2d1c508 (max_nunits=1, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: 	{ radius_101, radius_101 }
Water_vectorised_SIMD.cpp:356:28: note: node (external) 0x2d1c488 (max_nunits=1, refcnt=2) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: 	{ x_119, y_116 }
Water_vectorised_SIMD.cpp:356:28: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: 	{ 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 }
Water_vectorised_SIMD.cpp:356:28: note: node 0x2d1c188 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: op template: _74->x = _19;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 0 _74->x = _19;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 1 _74->y = _18;
Water_vectorised_SIMD.cpp:356:28: note: 	children 0x2d1c308
Water_vectorised_SIMD.cpp:356:28: note: node 0x2d1c308 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: op template: _440 = .VEC_FMADDSUB (radius_101, x_119, 7.575407977810179327438078189516090787947177886962890625e-2);
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 0 _19 = _13 - 7.575407977810179327438078189516090787947177886962890625e-2;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 1 _18 = _14 + 5.87079636588852260548065942202811129391193389892578125e-2;
Water_vectorised_SIMD.cpp:356:28: note: 	children 0x2d1c508 0x2d1c488 0x2d1c288
Water_vectorised_SIMD.cpp:356:28: note: node (constant) 0x2d1c288 (max_nunits=1, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: 	{ 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 }
Water_vectorised_SIMD.cpp:356:28: note: node 0x2d1c808 (max_nunits=2, refcnt=1) vector(2) double
Water_vectorised_SIMD.cpp:356:28: note: op template: _158->x = _13;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 0 _158->x = _13;
Water_vectorised_SIMD.cpp:356:28: note: 	stmt 1 _158->y = _14;
Water_vectorised_SIMD.cpp:356:28: note: 	children 0x2d1c108
Water_vectorised_SIMD.cpp:356:28: note: Cost model analysis: 
Water_vectorised_SIMD.cpp:356:28: note: Cost model analysis for part in loop 2:
  Vector cost: 120
  Scalar cost: 164
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x2d1c888 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: MEM[(struct _Vector_impl_data *)_103(D)]._M_start = iftmp.127_1267;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)_103(D)]._M_start = iftmp.127_1267;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)_103(D)]._M_finish = __cur_1999;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 2 MEM[(struct _Vector_impl_data *)_103(D)]._M_end_of_storage = _1269;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 3 MEM[(struct _Vector_impl_data *)_103(D) + 24B]._M_start = _1434;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 4 MEM[(struct _Vector_impl_data *)_103(D) + 24B]._M_finish = _1429;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 5 MEM[(struct _Vector_impl_data *)_103(D) + 24B]._M_end_of_storage = _1429;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 6 MEM[(struct _Vector_impl_data *)_103(D) + 48B]._M_start = _1454;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 7 MEM[(struct _Vector_impl_data *)_103(D) + 48B]._M_finish = _1449;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 8 MEM[(struct _Vector_impl_data *)_103(D) + 48B]._M_end_of_storage = _1449;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 9 MEM[(struct _Vector_impl_data *)_103(D) + 72B]._M_start = iftmp.136_778;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 10 MEM[(struct _Vector_impl_data *)_103(D) + 72B]._M_finish = __cur_1919;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 11 MEM[(struct _Vector_impl_data *)_103(D) + 72B]._M_end_of_storage = _779;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x2d1c908
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x2d1c908 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ iftmp.127_1267, __cur_1999, _1269, _1434, _1429, _1429, _1454, _1449, _1449, iftmp.136_778, __cur_1919, _779 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Cost model analysis for part in loop 0:
  Vector cost: 420
  Scalar cost: 192
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: not vectorized: vectorization is not profitable.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x2d1c608 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _44->x = _17;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _44->x = _17;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _44->y = _18;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x2d1c388
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x2d1c388 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _18 = _14 + 5.87079636588852260548065942202811129391193389892578125e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x2d1c108 0x2d1c588
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x2d1c108 (max_nunits=2, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _13 = radius_101 * x_119;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _13 = radius_101 * x_119;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _14 = radius_101 * y_116;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x2d1c508 0x2d1c488
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x2d1c508 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ radius_101, radius_101 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x2d1c488 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ x_119, y_116 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (constant) 0x2d1c588 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _13 = radius_101 * x_119;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform binary/unary operation.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: vect__13.1867_2894 = _441 * _2886;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand radius_101 * x_119, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform binary/unary operation.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: vect__17.1868_333 = vect__13.1867_2894 + { 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 };
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _44->x = _17;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand _13 + 7.575407977810179327438078189516090787947177886962890625e-2, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand _14 + 5.87079636588852260548065942202811129391193389892578125e-2, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:106:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: _44->x
/usr/include/c++/13/bits/stl_vector.h:106:4: note: created vectp.1870_334
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1870_334] = vect__17.1868_333;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x2d1c188 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _74->x = _19;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _74->x = _19;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _74->y = _18;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x2d1c308
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x2d1c308 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _440 = .VEC_FMADDSUB (radius_101, x_119, 7.575407977810179327438078189516090787947177886962890625e-2);
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _19 = _13 - 7.575407977810179327438078189516090787947177886962890625e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _18 = _14 + 5.87079636588852260548065942202811129391193389892578125e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x2d1c508 0x2d1c488 0x2d1c288
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x2d1c508 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ radius_101, radius_101 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x2d1c488 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ x_119, y_116 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (constant) 0x2d1c288 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _440 = .VEC_FMADDSUB (radius_101, x_119, 7.575407977810179327438078189516090787947177886962890625e-2);
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform call.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: vect__440.1871_2352 = .VEC_FMADDSUB (_441, _2886, { 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 });
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _74->x = _19;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand .VEC_FMADDSUB (radius_101, x_119, 7.575407977810179327438078189516090787947177886962890625e-2), type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand _14 + 5.87079636588852260548065942202811129391193389892578125e-2, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:106:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: _74->x
/usr/include/c++/13/bits/stl_vector.h:106:4: note: created vectp.1873_564
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1873_564] = vect__440.1871_2352;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x2d1c808 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _158->x = _13;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _158->x = _13;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _158->y = _14;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x2d1c108
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x2d1c108 (max_nunits=2, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _13 = radius_101 * x_119;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _13 = radius_101 * x_119;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _14 = radius_101 * y_116;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x2d1c508 0x2d1c488
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x2d1c508 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ radius_101, radius_101 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x2d1c488 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ x_119, y_116 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _158->x = _13;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand radius_101 * x_119, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand radius_101 * y_116, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:106:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: _158->x
/usr/include/c++/13/bits/stl_vector.h:106:4: note: created vectp.1875_2682
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1875_2682] = vect__13.1867_2894;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:106:4: optimized: basic block part vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** The result for vector mode V16QI would be the same
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: splitting region at dominance boundary bb512
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: splitting region at dominance boundary bb513
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: splitting region at dominance boundary bb359
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: splitting region at dominance boundary bb370
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb514
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1302, _1406);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 120
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb348
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb375
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb515
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1308, _1407);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 119
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb337
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb380
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb325
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (_1290);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 118
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb323
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:140:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: splitting region at dominance boundary bb384
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("basic_string::_M_create");
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb317
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: _1282 = __builtin_eh_pointer (117);
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_begin_catch (_1282);
/usr/include/c++/13/bits/stl_uninitialized.h:126:4: missed: not vectorized: statement can throw an exception: __cxa_rethrow ();
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_end_catch ();
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 116
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (iftmp.127_1267, _1413);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 114
/usr/include/c++/13/bits/stl_construct.h:88:18: missed: statement clobbers memory: Atoms::~Atoms (__first_1283);
/usr/include/c++/13/bits/stl_construct.h:162:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:162:4: missed: splitting region at dominance boundary bb460
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb516
Water_vectorised_SIMD.cpp:341:68: missed: statement clobbers memory: std::vector<Atoms>::~vector (&D.169017);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 53
Water_vectorised_SIMD.cpp:341:68: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:341:68: missed: splitting region at dominance boundary bb517
Water_vectorised_SIMD.cpp:341:68: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:341:68: missed: splitting region at dominance boundary bb281
Water_vectorised_SIMD.cpp:341:68: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:341:68: missed: splitting region at dominance boundary bb292
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb518
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1126, _1230);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 110
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb270
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb297
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb519
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1132, _1231);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 109
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb259
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb302
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb247
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (_1114);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 108
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb245
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:140:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: splitting region at dominance boundary bb306
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("basic_string::_M_create");
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb313
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: _1106 = __builtin_eh_pointer (107);
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_begin_catch (_1106);
/usr/include/c++/13/bits/stl_uninitialized.h:126:4: missed: not vectorized: statement can throw an exception: __cxa_rethrow ();
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_end_catch ();
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 106
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: splitting region at dominance boundary bb463
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1082, _1232);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 104
/usr/include/c++/13/bits/new_allocator.h:172:26: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/new_allocator.h:172:26: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: splitting region at dominance boundary bb307
Water_vectorised_SIMD.cpp:341:68: missed: statement clobbers memory: Atoms::~Atoms (&MEM <const struct Atoms[3]> [(void *)&D.169003 + 272B]);
Water_vectorised_SIMD.cpp:341:68: missed: statement clobbers memory: Atoms::~Atoms (&MEM <const struct Atoms[3]> [(void *)&D.169003 + 136B]);
Water_vectorised_SIMD.cpp:341:68: missed: statement clobbers memory: Atoms::~Atoms (&MEM <const struct Atoms[3]> [(void *)&D.169003]);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 50
Water_vectorised_SIMD.cpp:341:68: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:341:68: missed: splitting region at dominance boundary bb520
/usr/include/c++/13/bits/stl_construct.h:88:18: missed: statement clobbers memory: Atoms::~Atoms (__first_1107);
/usr/include/c++/13/bits/stl_construct.h:162:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:162:4: missed: splitting region at dominance boundary bb222
/usr/include/c++/13/bits/stl_construct.h:162:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:162:4: missed: splitting region at dominance boundary bb230
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb521
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_971, _1075);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 103
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb214
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb235
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb522
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_977, _1076);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 102
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb206
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb240
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb194
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&MEM[(struct Atoms *)&D.169003 + 272B].name);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 101
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb191
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:140:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: splitting region at dominance boundary bb649
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("basic_string::_M_create");
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb523
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb170
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb178
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb524
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_849, _953);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 100
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb162
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb183
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb525
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_855, _954);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 99
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb154
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb188
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb142
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&MEM[(struct Atoms *)&D.169003 + 136B].name);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 98
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb139
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:140:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: splitting region at dominance boundary bb650
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("basic_string::_M_create");
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb526
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb118
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb126
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb527
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_727, _831);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 97
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb110
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb131
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb528
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_733, _832);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 96
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb102
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb136
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb90
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&MEM[(struct Atoms *)&D.169003].name);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 95
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb88
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:140:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: splitting region at dominance boundary bb651
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("basic_string::_M_create");
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb469
/usr/include/c++/13/bits/basic_string.tcc:144:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:144:27: missed: splitting region at dominance boundary bb476
Water_vectorised_SIMD.cpp:362:1: missed: statement clobbers memory: Atoms::~Atoms (_133);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 49
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_710, 64);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 46
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb479
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_675, 40);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 44
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb482
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_654, 40);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 42
/usr/include/c++/13/bits/new_allocator.h:172:26: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: splitting region at dominance boundary bb485
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_627, 64);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 35
/usr/include/c++/13/bits/new_allocator.h:172:26: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: splitting region at dominance boundary bb488
Water_vectorised_SIMD.cpp:362:1: missed: statement clobbers memory: Atoms::~Atoms (&H2);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 28
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb491
Water_vectorised_SIMD.cpp:362:1: missed: statement clobbers memory: Atoms::~Atoms (&H1);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 19
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb529
Water_vectorised_SIMD.cpp:362:1: missed: statement clobbers memory: Atoms::~Atoms (&O);
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb530
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb531
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb532
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb533
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb534
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb535
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb536
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb537
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb3
Water_vectorised_SIMD.cpp:362:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:362:1: missed: splitting region at dominance boundary bb28
/usr/include/c++/13/bits/stl_vector.h:1910:24: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("cannot create std::vector larger than max_size()");
/usr/include/c++/13/bits/stl_vector.h:1910:24: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&O.name);
Water_vectorised_SIMD.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 84
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&D.168920);
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:388:18: missed: couldn't vectorize loop
Water_vectorised_SIMD.cpp:388:18: missed: not vectorized: control flow in loop.
Water_vectorised_SIMD.cpp:377:5: note: vectorized 0 loops in function.
Water_vectorised_SIMD.cpp:377:5: missed: splitting region at control altering definition sys = MakeWater (_4); [return slot optimization]
Water_vectorised_SIMD.cpp:378:43: missed: statement clobbers memory: std::vector<std::__cxx11::basic_string<char> >::vector<char**> (&D.169253, argv_21(D), _3, &D.169252);
Water_vectorised_SIMD.cpp:378:43: missed: not vectorized: statement can throw an exception: Sim_Configuration::Sim_Configuration (&sc, &D.169253);
Water_vectorised_SIMD.cpp:378:43: missed: statement clobbers memory: std::vector<std::__cxx11::basic_string<char> >::~vector (&D.169253);
Water_vectorised_SIMD.cpp:380:38: missed: not vectorized: statement can throw an exception: sys = MakeWater (_4); [return slot optimization]
Water_vectorised_SIMD.cpp:380:38: note: ***** Analysis failed with vector mode V2DI
Water_vectorised_SIMD.cpp:380:38: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
Water_vectorised_SIMD.cpp:380:38: missed: splitting region at control altering definition _27 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_bond.146_9);
Water_vectorised_SIMD.cpp:381:35: missed: not vectorized: statement can throw an exception: std::basic_ofstream<char>::basic_ofstream (&file, &sc.filename, 16);
Water_vectorised_SIMD.cpp:383:16: missed: not vectorized: statement can throw an exception: WriteOutput (&sys, &file);
Water_vectorised_SIMD.cpp:385:58: missed: statement clobbers memory: tstart = std::chrono::_V2::system_clock::now ();
Water_vectorised_SIMD.cpp:389:30: missed: not vectorized: statement can throw an exception: BuildNeighborList (&sys);
Water_vectorised_SIMD.cpp:391:25: missed: statement clobbers memory: UpdateBondForces (&sys);
Water_vectorised_SIMD.cpp:392:26: missed: statement clobbers memory: UpdateAngleForces (&sys);
Water_vectorised_SIMD.cpp:393:30: missed: statement clobbers memory: UpdateNonBondedForces (&sys);
Water_vectorised_SIMD.cpp:394:18: missed: statement clobbers memory: UpdateKDK (&sys, &sc);
Water_vectorised_SIMD.cpp:397:24: missed: not vectorized: statement can throw an exception: WriteOutput (&sys, &file);
Water_vectorised_SIMD.cpp:400:56: missed: statement clobbers memory: tend = std::chrono::_V2::system_clock::now ();
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "Accumulated forces Bonds   : ", 29);
/usr/include/c++/13/ostream:223:25: missed: not vectorized: statement can throw an exception: _27 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_bond.146_9);
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/ostream:223:25: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb18
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:223:25: missed: splitting region at control altering definition _61 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_angle.147_10);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (_27, "\n", 1);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "Accumulated forces Angles  : ", 29);
/usr/include/c++/13/ostream:223:25: missed: not vectorized: statement can throw an exception: _61 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_angle.147_10);
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/ostream:223:25: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb24
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:223:25: missed: splitting region at control altering definition _69 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_non_bond.148_11);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (_61, "\n", 1);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "Accumulated forces Non-bond: ", 29);
/usr/include/c++/13/ostream:223:25: missed: not vectorized: statement can throw an exception: _69 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_non_bond.148_11);
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/ostream:223:25: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb30
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:223:25: missed: splitting region at control altering definition _81 = std::basic_ostream<char>::_M_insert<double> (&cout, _13);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (_69, "\n", 1);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "Elapsed total time:       ", 26);
/usr/include/c++/13/ostream:223:25: missed: not vectorized: statement can throw an exception: _81 = std::basic_ostream<char>::_M_insert<double> (&cout, _13);
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode V2DI
/usr/include/c++/13/ostream:223:25: note: ***** Skipping vector mode V16QI, which would repeat the analysis for V2DI
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb36
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb49
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (_81, "\n", 1);
Water_vectorised_SIMD.cpp:410:1: missed: statement clobbers memory: std::basic_ofstream<char>::~basic_ofstream (&file);
Water_vectorised_SIMD.cpp:137:7: missed: statement clobbers memory: Molecules::~Molecules (&sys.molecules);
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&sc.filename);
Water_vectorised_SIMD.cpp:410:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:410:1: missed: splitting region at dominance boundary bb13
Water_vectorised_SIMD.cpp:410:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:410:1: missed: splitting region at dominance boundary bb10
Water_vectorised_SIMD.cpp:410:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:410:1: missed: splitting region at dominance boundary bb40
Water_vectorised_SIMD.cpp:410:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:410:1: missed: splitting region at dominance boundary bb41
Water_vectorised_SIMD.cpp:410:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:410:1: missed: splitting region at dominance boundary bb43
Water_vectorised_SIMD.cpp:410:1: missed: statement clobbers memory: std::basic_ofstream<char>::~basic_ofstream (&file);
Water_vectorised_SIMD.cpp:377:5: missed: not vectorized: statement can throw an exception: resx 12
Water_vectorised_SIMD.cpp:410:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:410:1: missed: splitting region at dominance boundary bb44
Water_vectorised_SIMD.cpp:410:1: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:410:1: missed: splitting region at dominance boundary bb46
Water_vectorised_SIMD.cpp:137:7: missed: statement clobbers memory: Molecules::~Molecules (&sys.molecules);
Water_vectorised_SIMD.cpp:377:5: missed: not vectorized: statement can throw an exception: resx 11
Water_vectorised_SIMD.cpp:137:7: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:137:7: missed: splitting region at dominance boundary bb47
Water_vectorised_SIMD.cpp:137:7: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:137:7: missed: splitting region at dominance boundary bb39
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&sc.filename);
Water_vectorised_SIMD.cpp:145:7: note: ***** Analysis failed with vector mode VOID
Water_vectorised_SIMD.cpp:378:43: missed: statement clobbers memory: std::vector<std::__cxx11::basic_string<char> >::~vector (&D.169253);
Water_vectorised_SIMD.cpp:378:43: note: ***** Analysis failed with vector mode VOID
