/usr/include/c++/13/bits/stl_iterator.h:1148:47: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_iterator.h:1148:47: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_heap.h:229:28: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_heap.h:229:28: missed: not vectorized: number of iterations cannot be computed.
/usr/include/c++/13/bits/stl_heap.h:229:28: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_heap.h:229:28: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_heap.h:224:5: note: vectorized 0 loops in function.
/usr/include/c++/13/bits/stl_heap.h:249:5: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_heap.h:249:5: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
task3_variants/vec_all_pragmas.cpp:21:41: note: ***** Analysis succeeded with vector mode V4DF
task3_variants/vec_all_pragmas.cpp:21:41: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:21:41: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f748 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: <retval>.x = _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 <retval>.x = _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 <retval>.y = _7;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f7c8
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f7c8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _5 = scalar_3(D) * _4;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _5 = scalar_3(D) * _4;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _7 = scalar_3(D) * _6;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f848 0x477f8c8
task3_variants/vec_all_pragmas.cpp:21:41: note: node (external) 0x477f848 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: 	{ scalar_3(D), scalar_3(D) }
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f8c8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _4 = y_2(D)->x;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _4 = y_2(D)->x;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _6 = y_2(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:21:41: note: Cost model analysis for part in loop 0:
  Vector cost: 44
  Scalar cost: 80
task3_variants/vec_all_pragmas.cpp:21:41: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:21:41: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f748 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: <retval>.x = _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 <retval>.x = _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 <retval>.y = _7;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f7c8
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f7c8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _5 = scalar_3(D) * _4;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _5 = scalar_3(D) * _4;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _7 = scalar_3(D) * _6;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f848 0x477f8c8
task3_variants/vec_all_pragmas.cpp:21:41: note: node (external) 0x477f848 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: 	{ scalar_3(D), scalar_3(D) }
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f8c8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _4 = y_2(D)->x;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _4 = y_2(D)->x;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _6 = y_2(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: ------>vectorizing SLP node starting from: _4 = y_2(D)->x;
task3_variants/vec_all_pragmas.cpp:21:41: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:21:41: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: y_2(D)->x
task3_variants/vec_all_pragmas.cpp:21:41: note: created vectp.1031_15
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vect__4.1032_16 = MEM <const vector(2) double> [(double *)vectp.1031_15];
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vectp.1031_17 = vectp.1031_15 + 8;
task3_variants/vec_all_pragmas.cpp:21:41: note: ------>vectorizing SLP node starting from: _5 = scalar_3(D) * _4;
task3_variants/vec_all_pragmas.cpp:21:41: note: vect_is_simple_use: operand y_2(D)->x, type of def: internal
task3_variants/vec_all_pragmas.cpp:21:41: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vect__5.1033_18 = _14 * vect__4.1032_16;
task3_variants/vec_all_pragmas.cpp:21:41: note: ------>vectorizing SLP node starting from: <retval>.x = _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: vect_is_simple_use: operand scalar_3(D) * _4, type of def: internal
task3_variants/vec_all_pragmas.cpp:21:41: note: vect_is_simple_use: operand scalar_3(D) * _6, type of def: internal
task3_variants/vec_all_pragmas.cpp:21:41: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:21:41: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: <retval>.x
task3_variants/vec_all_pragmas.cpp:21:41: note: created &<retval>
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: MEM <vector(2) double> [(double *)&<retval>] = vect__5.1033_18;
task3_variants/vec_all_pragmas.cpp:21:41: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:21:41: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:21:41: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:21:41: note: ***** Analysis succeeded with vector mode V4DF
task3_variants/vec_all_pragmas.cpp:21:41: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:21:41: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f748 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: <retval>.x = _7;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 <retval>.x = _7;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 <retval>.y = _12;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f7c8
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f7c8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _7 = _3 - _6;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _7 = _3 - _6;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _12 = _9 - _11;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f848 0x477f9c8
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f848 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _3 = _1 * _2;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _3 = _1 * _2;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _9 = _4 * _8;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f8c8 0x477f948
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f8c8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _1 = a_17(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _1 = a_17(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _4 = a_17(D)->z;
task3_variants/vec_all_pragmas.cpp:21:41: note: node (external) 0x477f948 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _2 = b_18(D)->z;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _8 = b_18(D)->x;
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f9c8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _6 = _4 * _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _6 = _4 * _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _11 = _2 * _10;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477fac8 0x477fb48
task3_variants/vec_all_pragmas.cpp:21:41: note: node (external) 0x477fac8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _4 = a_17(D)->z;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _10 = a_17(D)->x;
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477fb48 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _5 = b_18(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _5 = b_18(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _2 = b_18(D)->z;
task3_variants/vec_all_pragmas.cpp:21:41: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:21:41: note: Cost model analysis for part in loop 0:
  Vector cost: 92
  Scalar cost: 152
task3_variants/vec_all_pragmas.cpp:21:41: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:21:41: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f748 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: <retval>.x = _7;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 <retval>.x = _7;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 <retval>.y = _12;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f7c8
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f7c8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _7 = _3 - _6;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _7 = _3 - _6;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _12 = _9 - _11;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f848 0x477f9c8
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f848 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _3 = _1 * _2;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _3 = _1 * _2;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _9 = _4 * _8;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477f8c8 0x477f948
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f8c8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _1 = a_17(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _1 = a_17(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _4 = a_17(D)->z;
task3_variants/vec_all_pragmas.cpp:21:41: note: node (external) 0x477f948 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _2 = b_18(D)->z;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _8 = b_18(D)->x;
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477f9c8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _6 = _4 * _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _6 = _4 * _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _11 = _2 * _10;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x477fac8 0x477fb48
task3_variants/vec_all_pragmas.cpp:21:41: note: node (external) 0x477fac8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _4 = a_17(D)->z;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _10 = a_17(D)->x;
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x477fb48 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: _5 = b_18(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 _5 = b_18(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 _2 = b_18(D)->z;
task3_variants/vec_all_pragmas.cpp:21:41: note: ------>vectorizing SLP node starting from: _1 = a_17(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:21:41: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: a_17(D)->y
task3_variants/vec_all_pragmas.cpp:21:41: note: created vectp.1040_23
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vect__1.1041_24 = MEM <const vector(2) double> [(double *)vectp.1040_23];
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vectp.1040_25 = vectp.1040_23 + 8;
task3_variants/vec_all_pragmas.cpp:21:41: note: extracting lane for live stmt _1 = a_17(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: ------>vectorizing SLP node starting from: _3 = _1 * _2;
task3_variants/vec_all_pragmas.cpp:21:41: note: vect_is_simple_use: operand a_17(D)->y, type of def: internal
task3_variants/vec_all_pragmas.cpp:21:41: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vect__3.1042_28 = vect__1.1041_24 * _27;
task3_variants/vec_all_pragmas.cpp:21:41: note: ------>vectorizing SLP node starting from: _5 = b_18(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:21:41: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: b_18(D)->z
task3_variants/vec_all_pragmas.cpp:21:41: note: created vectp.1044_30
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vectp.1044_31 = vectp.1044_30 + 18446744073709551608;
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vect__5.1045_32 = MEM <const vector(2) double> [(double *)vectp.1044_31];
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vectp.1044_33 = vectp.1044_31 + 8;
task3_variants/vec_all_pragmas.cpp:21:41: note: extracting lane for live stmt _5 = b_18(D)->y;
task3_variants/vec_all_pragmas.cpp:21:41: note: ------>vectorizing SLP node starting from: _6 = _4 * _5;
task3_variants/vec_all_pragmas.cpp:21:41: note: vect_is_simple_use: operand b_18(D)->y, type of def: internal
task3_variants/vec_all_pragmas.cpp:21:41: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vect__6.1046_35 = _29 * vect__5.1045_32;
task3_variants/vec_all_pragmas.cpp:21:41: note: ------>vectorizing SLP node starting from: _7 = _3 - _6;
task3_variants/vec_all_pragmas.cpp:21:41: note: vect_is_simple_use: operand _1 * _2, type of def: internal
task3_variants/vec_all_pragmas.cpp:21:41: note: vect_is_simple_use: operand _4 * _5, type of def: internal
task3_variants/vec_all_pragmas.cpp:21:41: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: vect__7.1047_36 = vect__3.1042_28 - vect__6.1046_35;
task3_variants/vec_all_pragmas.cpp:21:41: note: ------>vectorizing SLP node starting from: <retval>.x = _7;
task3_variants/vec_all_pragmas.cpp:21:41: note: vect_is_simple_use: operand _3 - _6, type of def: internal
task3_variants/vec_all_pragmas.cpp:21:41: note: vect_is_simple_use: operand _9 - _11, type of def: internal
task3_variants/vec_all_pragmas.cpp:21:41: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:21:41: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: <retval>.x
task3_variants/vec_all_pragmas.cpp:21:41: note: created &<retval>
task3_variants/vec_all_pragmas.cpp:21:41: note: add new stmt: MEM <vector(2) double> [(double *)&<retval>] = vect__7.1047_36;
task3_variants/vec_all_pragmas.cpp:21:41: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:21:41: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:21:41: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:66:44: note: ***** Analysis failed with vector mode V4DF
task3_variants/vec_all_pragmas.cpp:66:44: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:66:44: note: ***** Re-trying analysis with vector mode V16QI
task3_variants/vec_all_pragmas.cpp:66:44: note: ***** Analysis failed with vector mode V16QI
task3_variants/vec_all_pragmas.cpp:66:44: note: ***** Re-trying analysis with vector mode V8QI
task3_variants/vec_all_pragmas.cpp:66:44: note: ***** Analysis failed with vector mode V8QI
task3_variants/vec_all_pragmas.cpp:66:44: note: ***** The result for vector mode V4QI would be the same
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
task3_variants/vec_all_pragmas.cpp:124:7: note: vectorized 0 loops in function.
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_49, _54);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_75, _55);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_31, _56);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_23, _57);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_89, _94);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_81, _95);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_73, _96);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_64, _67);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_135, _98);
task3_variants/vec_all_pragmas.cpp:124:7: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:124:7: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: not vectorized: control flow in loop.
task3_variants/vec_all_pragmas.cpp:153:5: note: vectorized 0 loops in function.
task3_variants/vec_all_pragmas.cpp:153:5: missed: splitting region at control altering definition _109 = std::__cxx11::basic_string<char>::_M_create (&arg, &__dnew, 0);
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_95, "trajectory.txt", 14);
/usr/include/c++/13/bits/basic_string.tcc:229:13: missed: not vectorized: statement can throw an exception: _109 = std::__cxx11::basic_string<char>::_M_create (&arg, &__dnew, 0);
task3_variants/vec_all_pragmas.cpp:153:58: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:153:58: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:153:58: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:153:58: note: node 0x4874718 (max_nunits=2, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:153:58: note: op template: *this_19(D).steps = 10000;
task3_variants/vec_all_pragmas.cpp:153:58: note: 	stmt 0 *this_19(D).steps = 10000;
task3_variants/vec_all_pragmas.cpp:153:58: note: 	stmt 1 *this_19(D).no_mol = 100;
task3_variants/vec_all_pragmas.cpp:153:58: note: 	children 0x4874798
task3_variants/vec_all_pragmas.cpp:153:58: note: node (constant) 0x4874798 (max_nunits=1, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:153:58: note: 	{ 10000, 100 }
task3_variants/vec_all_pragmas.cpp:153:58: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:153:58: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:153:58: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:153:58: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:153:58: note: node 0x4874718 (max_nunits=2, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:153:58: note: op template: *this_19(D).steps = 10000;
task3_variants/vec_all_pragmas.cpp:153:58: note: 	stmt 0 *this_19(D).steps = 10000;
task3_variants/vec_all_pragmas.cpp:153:58: note: 	stmt 1 *this_19(D).no_mol = 100;
task3_variants/vec_all_pragmas.cpp:153:58: note: 	children 0x4874798
task3_variants/vec_all_pragmas.cpp:153:58: note: node (constant) 0x4874798 (max_nunits=1, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:153:58: note: 	{ 10000, 100 }
task3_variants/vec_all_pragmas.cpp:153:58: note: ------>vectorizing SLP node starting from: *this_19(D).steps = 10000;
task3_variants/vec_all_pragmas.cpp:153:58: note: vect_is_simple_use: operand 100, type of def: constant
task3_variants/vec_all_pragmas.cpp:153:58: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:153:58: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: *this_19(D).steps
task3_variants/vec_all_pragmas.cpp:153:58: note: created vectp.1078_129
task3_variants/vec_all_pragmas.cpp:153:58: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int *)vectp.1078_129] = { 10000, 100 };
task3_variants/vec_all_pragmas.cpp:153:58: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:153:58: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:153:58: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:153:58: missed: splitting region at dominance boundary bb5
task3_variants/vec_all_pragmas.cpp:153:58: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:153:58: missed: splitting region at dominance boundary bb9
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb10
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_179, _32, _43);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at loop 1 exit at bb69
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _180 = __builtin_memcmp (_92, "-dt", 3);
/usr/include/c++/13/ext/string_conversions.h:82:34: missed: statement clobbers memory: _184 = strtof (_65, &__endptr);
task3_variants/vec_all_pragmas.cpp:167:20: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:167:20: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
task3_variants/vec_all_pragmas.cpp:167:20: missed: splitting region at dominance boundary bb67
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: not vectorized: statement can throw an exception: std::__throw_out_of_range ("stof");
/usr/include/c++/13/ext/string_conversions.h:88:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: splitting region at dominance boundary bb75
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: not vectorized: statement can throw an exception: std::__throw_invalid_argument ("stof");
/usr/include/c++/13/ext/string_conversions.h:85:31: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: splitting region at dominance boundary bb34
task3_variants/vec_all_pragmas.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 17
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Analysis failed with vector mode V8SI
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SI
/usr/include/c++/13/ext/string_conversions.h:66:41: missed: splitting region at loop 1 exit at bb113
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _148 = __builtin_memcmp (_103, "-no_mol", 7);
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _164 = __builtin_memcmp (_103, "-fwrite", 7);
/usr/include/c++/13/ext/string_conversions.h:82:34: missed: statement clobbers memory: _168 = strtol (_60, &__endptr, 10);
task3_variants/vec_all_pragmas.cpp:165:29: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:165:29: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
task3_variants/vec_all_pragmas.cpp:165:29: missed: splitting region at dominance boundary bb112
task3_variants/vec_all_pragmas.cpp:165:29: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:165:29: missed: splitting region at dominance boundary bb54
task3_variants/vec_all_pragmas.cpp:165:29: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:165:29: missed: splitting region at dominance boundary bb51
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: not vectorized: statement can throw an exception: std::__throw_out_of_range ("stoi");
/usr/include/c++/13/ext/string_conversions.h:88:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: splitting region at dominance boundary bb60
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: not vectorized: statement can throw an exception: std::__throw_invalid_argument ("stoi");
/usr/include/c++/13/ext/string_conversions.h:85:31: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: splitting region at dominance boundary bb35
task3_variants/vec_all_pragmas.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 16
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Analysis failed with vector mode V8SI
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SI
/usr/include/c++/13/ext/string_conversions.h:66:41: missed: splitting region at loop 1 exit at bb108
/usr/include/c++/13/ext/string_conversions.h:82:34: missed: statement clobbers memory: _152 = strtol (_55, &__endptr, 10);
task3_variants/vec_all_pragmas.cpp:163:24: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:163:24: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
task3_variants/vec_all_pragmas.cpp:163:24: missed: splitting region at dominance boundary bb107
task3_variants/vec_all_pragmas.cpp:163:24: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:163:24: missed: splitting region at dominance boundary bb39
task3_variants/vec_all_pragmas.cpp:163:24: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:163:24: missed: splitting region at dominance boundary bb36
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: not vectorized: statement can throw an exception: std::__throw_out_of_range ("stoi");
/usr/include/c++/13/ext/string_conversions.h:88:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: splitting region at dominance boundary bb45
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: not vectorized: statement can throw an exception: std::__throw_invalid_argument ("stoi");
/usr/include/c++/13/ext/string_conversions.h:85:31: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: splitting region at dominance boundary bb17
task3_variants/vec_all_pragmas.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 15
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Analysis failed with vector mode V8SI
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SI
/usr/include/c++/13/ext/string_conversions.h:66:41: missed: splitting region at loop 1 exit at bb104
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _132 = __builtin_memcmp (_234, "-steps", 6);
/usr/include/c++/13/ext/string_conversions.h:82:34: missed: statement clobbers memory: _136 = strtol (_50, &__endptr, 10);
task3_variants/vec_all_pragmas.cpp:161:23: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:161:23: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
task3_variants/vec_all_pragmas.cpp:161:23: missed: splitting region at dominance boundary bb103
task3_variants/vec_all_pragmas.cpp:161:23: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:161:23: missed: splitting region at dominance boundary bb24
task3_variants/vec_all_pragmas.cpp:161:23: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:161:23: missed: splitting region at dominance boundary bb21
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: not vectorized: statement can throw an exception: std::__throw_out_of_range ("stoi");
/usr/include/c++/13/ext/string_conversions.h:88:27: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:88:27: missed: splitting region at dominance boundary bb30
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: not vectorized: statement can throw an exception: std::__throw_invalid_argument ("stoi");
/usr/include/c++/13/ext/string_conversions.h:85:31: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ext/string_conversions.h:85:31: missed: splitting region at dominance boundary bb11
task3_variants/vec_all_pragmas.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 14
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Analysis failed with vector mode V8SI
/usr/include/c++/13/ext/string_conversions.h:66:41: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V8SI
/usr/include/c++/13/ext/string_conversions.h:66:41: missed: splitting region at dominance boundary bb65
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _119 = __builtin_memcmp (_97, "-h", 2);
/usr/include/c++/13/bits/basic_string.h:3731:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:3731:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:3731:9: missed: splitting region at dominance boundary bb82
/usr/include/c++/13/bits/char_traits.h:389:25: missed: statement clobbers memory: _193 = __builtin_memcmp (prephitmp_162, "-ofile", 6);
/usr/include/c++/13/bits/basic_string.h:3731:9: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:3731:9: missed: splitting region at loop 1 exit at bb83
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "---> error: the argument type is not recognized \n", 49);
/usr/include/c++/13/ostream:667:18: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:667:18: missed: splitting region at dominance boundary bb80
/usr/include/c++/13/ostream:667:18: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:667:18: missed: splitting region at loop 1 exit at bb81
/usr/include/c++/13/bits/basic_string.h:1608:17: missed: not vectorized: statement can throw an exception: std::__cxx11::basic_string<char>::_M_assign (_1, _72);
/usr/include/c++/13/bits/basic_string.h:1608:17: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:1608:17: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:1608:17: missed: splitting region at dominance boundary bb84
/usr/include/c++/13/bits/basic_string.h:1608:17: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:1608:17: missed: splitting region at dominance boundary bb85
/usr/include/c++/13/bits/basic_string.h:1608:17: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:1608:17: missed: splitting region at loop 1 exit at bb88
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_203, _206);
task3_variants/vec_all_pragmas.cpp:154:29: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:154:29: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
task3_variants/vec_all_pragmas.cpp:154:29: missed: splitting region at dominance boundary bb89
task3_variants/vec_all_pragmas.cpp:175:12: note: ***** Analysis failed with vector mode V4DF
task3_variants/vec_all_pragmas.cpp:175:12: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DF
task3_variants/vec_all_pragmas.cpp:175:12: missed: splitting region at dominance boundary bb96
task3_variants/vec_all_pragmas.cpp:176:5: note: ***** Analysis failed with vector mode V4DF
task3_variants/vec_all_pragmas.cpp:176:5: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DF
task3_variants/vec_all_pragmas.cpp:176:5: missed: splitting region at dominance boundary bb13
task3_variants/vec_all_pragmas.cpp:176:5: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:176:5: missed: splitting region at dominance boundary bb91
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "MD -steps <number of steps> -no_mol <number of molecules>", 57);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, " -fwrite <io frequency> -dt <size of timestep> -ofile <filename> \n", 66);
/usr/include/c++/13/ostream:667:18: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:667:18: missed: splitting region at dominance boundary bb94
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&arg);
task3_variants/vec_all_pragmas.cpp:153:5: missed: not vectorized: statement can throw an exception: resx 7
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb16
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (_1);
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:159:21: missed: statement clobbers memory: exit (0);
task3_variants/vec_all_pragmas.cpp:159:21: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:225:27: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:225:27: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
task3_variants/vec_all_pragmas.cpp:230:17: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: not vectorized: no vectype for stmt: _81 = MEM[(struct vector *)_27 + 64B].D.93080._M_impl.D.92419._M_start;
 scalar_type: struct Vec3 *
task3_variants/vec_all_pragmas.cpp:222:6: note: vectorized 1 loops in function.
task3_variants/vec_all_pragmas.cpp:230:17: missed: statement clobbers memory: __builtin_memset (&D.112140, 0, 8);
task3_variants/vec_all_pragmas.cpp:41:11: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:41:11: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:41:11: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a74b8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_52].x = _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_52].x = _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_52].y = _48;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a7538
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7538 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _46 = _45 - _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _46 = _45 - _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _48 = _47 - _62;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a75b8 0x48a7638
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a75b8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _45 = MEM[(struct Vec3 *)_52].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _45 = MEM[(struct Vec3 *)_52].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _47 = MEM[(struct Vec3 *)_52].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7638 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _61 = _29 * _72;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _61 = _29 * _72;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _62 = _29 * _75;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a76b8 0x48a7738
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48a76b8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _29, _29 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7738 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _72 = _70 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _72 = _70 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _75 = _73 - _74;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a77b8 0x48a7838
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a77b8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _70 = MEM[(const struct Vec3 *)_80].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _70 = MEM[(const struct Vec3 *)_80].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _73 = MEM[(const struct Vec3 *)_80].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7838 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _71 = MEM[(const struct Vec3 &)_83].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _71 = MEM[(const struct Vec3 &)_83].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _74 = MEM[(const struct Vec3 &)_83].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7938 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_60].x = _54;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_60].x = _54;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_60].y = _56;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a79b8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a79b8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _54 = _53 + _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _54 = _53 + _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _56 = _55 + _62;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a7a38 0x48a7638
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7a38 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _53 = MEM[(struct Vec3 *)_60].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _53 = MEM[(struct Vec3 *)_60].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _55 = MEM[(struct Vec3 *)_60].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis for part in loop 4:
  Vector cost: 148
  Scalar cost: 256
task3_variants/vec_all_pragmas.cpp:41:11: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a74b8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_52].x = _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_52].x = _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_52].y = _48;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a7538
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7538 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _46 = _45 - _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _46 = _45 - _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _48 = _47 - _62;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a75b8 0x48a7638
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a75b8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _45 = MEM[(struct Vec3 *)_52].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _45 = MEM[(struct Vec3 *)_52].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _47 = MEM[(struct Vec3 *)_52].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7638 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _61 = _29 * _72;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _61 = _29 * _72;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _62 = _29 * _75;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a76b8 0x48a7738
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48a76b8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _29, _29 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7738 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _72 = _70 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _72 = _70 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _75 = _73 - _74;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a77b8 0x48a7838
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a77b8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _70 = MEM[(const struct Vec3 *)_80].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _70 = MEM[(const struct Vec3 *)_80].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _73 = MEM[(const struct Vec3 *)_80].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7838 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _71 = MEM[(const struct Vec3 &)_83].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _71 = MEM[(const struct Vec3 &)_83].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _74 = MEM[(const struct Vec3 &)_83].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _45 = MEM[(struct Vec3 *)_52].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_52].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1109_114
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__45.1110_115 = MEM <vector(2) double> [(double *)vectp.1109_114];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1109_104 = vectp.1109_114 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _70 = MEM[(const struct Vec3 *)_80].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_80].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1112_119
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__70.1113_120 = MEM <const vector(2) double> [(double *)vectp.1112_119];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1112_16 = vectp.1112_119 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _71 = MEM[(const struct Vec3 &)_83].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_83].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1115_123
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__71.1116_8 = MEM <const vector(2) double> [(double *)vectp.1115_123];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1115_89 = vectp.1115_123 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _72 = _70 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_80].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_83].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__72.1117_116 = vect__70.1113_120 - vect__71.1116_8;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _72 = _70 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _75 = _73 - _74;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _61 = _29 * _72;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _70 - _71, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__61.1118_102 = _118 * vect__72.1117_116;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _61 = _29 * _72;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _62 = _29 * _75;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _46 = _45 - _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_52].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _29 * _72, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__46.1119_132 = vect__45.1110_115 - vect__61.1118_102;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_52].x = _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _45 - _61, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _47 - _62, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_52].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1121_86
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1121_86] = vect__46.1119_132;
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7938 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_60].x = _54;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_60].x = _54;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_60].y = _56;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a79b8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a79b8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _54 = _53 + _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _54 = _53 + _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _56 = _55 + _62;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a7a38 0x48a7638
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7a38 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _53 = MEM[(struct Vec3 *)_60].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _53 = MEM[(struct Vec3 *)_60].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _55 = MEM[(struct Vec3 *)_60].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7638 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _61 = _29 * _72;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _61 = _29 * _72;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _62 = _29 * _75;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a76b8 0x48a7738
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48a76b8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _29, _29 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7738 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _72 = _70 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _72 = _70 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _75 = _73 - _74;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48a77b8 0x48a7838
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a77b8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _70 = MEM[(const struct Vec3 *)_80].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _70 = MEM[(const struct Vec3 *)_80].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _73 = MEM[(const struct Vec3 *)_80].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48a7838 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _71 = MEM[(const struct Vec3 &)_83].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _71 = MEM[(const struct Vec3 &)_83].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _74 = MEM[(const struct Vec3 &)_83].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _53 = MEM[(struct Vec3 *)_60].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_60].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1123_7
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__53.1124_111 = MEM <vector(2) double> [(double *)vectp.1123_7];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1123_129 = vectp.1123_7 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _54 = _53 + _61;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_60].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _29 * _72, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__54.1125_128 = vect__53.1124_111 + vect__61.1118_102;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_60].x = _54;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _53 + _61, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _55 + _62, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_60].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1127_127
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1127_127] = vect__54.1125_128;
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:41:11: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:244:29: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:244:29: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
task3_variants/vec_all_pragmas.cpp:250:17: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: not vectorized: no vectype for stmt: _173 = MEM[(struct vector *)_27 + 64B].D.93080._M_impl.D.92419._M_start;
 scalar_type: struct Vec3 *
task3_variants/vec_all_pragmas.cpp:241:6: note: vectorized 1 loops in function.
task3_variants/vec_all_pragmas.cpp:250:17: missed: statement clobbers memory: __builtin_memset (&D.112223, 0, 8);
task3_variants/vec_all_pragmas.cpp:41:11: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:41:11: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:41:11: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e74f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_66].x = _60;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_66].x = _60;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_66].y = _62;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7578
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7578 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _60 = _59 + _86;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _60 = _59 + _86;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _62 = _61 + _87;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e75f8 0x48e7678
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e75f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _59 = MEM[(struct Vec3 *)_66].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _59 = MEM[(struct Vec3 *)_66].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _61 = MEM[(struct Vec3 *)_66].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7678 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _86 = _40 * _92;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _86 = _40 * _92;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _87 = _40 * _93;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e76f8 0x48e7778
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e76f8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _40, _40 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7778 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _92 = _103 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _92 = _103 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _93 = _106 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e77f8 0x48e83f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e77f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _103 = _101 - _102;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _103 = _101 - _102;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _106 = _104 - _105;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7878 0x48e7f78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7878 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _101 = _133 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _101 = _133 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _104 = _136 * _155;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e78f8 0x48e7d78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e78f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7978 0x48e7cf8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7978 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _131 = _155 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _131 = _155 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e79f8 0x48e7b78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e79f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7a78 0x48e7af8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7a78 (max_nunits=2, refcnt=2) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7af8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7b78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7bf8 0x48e7c78
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7bf8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _168 = MEM[(const struct Vec3 *)_172].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7c78 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _169 = MEM[(const struct Vec3 &)_175].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7cf8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _132 = _159 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _132 = _159 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7d78 0x48e7e78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7d78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7bf8 0x48e7df8
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7df8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _158 = MEM[(const struct Vec3 &)_161].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7e78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7a78 0x48e7ef8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7ef8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7f78 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _102 = _136 * _157;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _102 = _136 * _157;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _105 = _130 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7ff8 0x48e80f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7ff8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _130 = _128 - _129;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8078 0x48e8278
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8078 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _128 = _159 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e80f8 0x48e7e78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e80f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8178 0x48e81f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8178 (max_nunits=2, refcnt=2) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _168 = MEM[(const struct Vec3 *)_172].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e81f8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _158 = MEM[(const struct Vec3 &)_161].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8278 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _129 = _157 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e79f8 0x48e82f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e82f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8178 0x48e8378
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8378 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _169 = MEM[(const struct Vec3 &)_175].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e83f8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _100, _100 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e84f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_74].x = _68;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_74].x = _68;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_74].y = _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8578
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8578 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _68 = _67 - _224;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _68 = _67 - _224;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _70 = _69 - _223;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e85f8 0x48e8678
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e85f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _67 = MEM[(struct Vec3 *)_74].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _67 = MEM[(struct Vec3 *)_74].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _69 = MEM[(struct Vec3 *)_74].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8678 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _224 = _86 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _224 = _86 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _223 = _87 + _90;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7678 0x48e86f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e86f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _89 = _39 * _110;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _89 = _39 * _110;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _90 = _39 * _111;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8778 0x48e87f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e8778 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _39, _39 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e87f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _110 = _121 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _110 = _121 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _111 = _124 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8878 0x48e89f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8878 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _121 = _119 - _120;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _121 = _119 - _120;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _124 = _122 - _123;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e88f8 0x48e8978
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e88f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _119 = _136 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _119 = _136 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _122 = _130 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7ff8 0x48e82f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8978 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _120 = _133 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _120 = _133 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _123 = _136 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e78f8 0x48e7b78
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e89f8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _118, _118 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8af8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_85].x = _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_85].x = _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_85].y = _81;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8b78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8b78 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _79 = _78 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _79 = _78 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _81 = _80 + _90;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8bf8 0x48e86f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8bf8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _78 = MEM[(struct Vec3 *)_85].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _78 = MEM[(struct Vec3 *)_85].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _80 = MEM[(struct Vec3 *)_85].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis for part in loop 4:
  Vector cost: 664
  Scalar cost: 952
task3_variants/vec_all_pragmas.cpp:41:11: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e74f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_66].x = _60;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_66].x = _60;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_66].y = _62;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7578
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7578 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _60 = _59 + _86;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _60 = _59 + _86;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _62 = _61 + _87;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e75f8 0x48e7678
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e75f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _59 = MEM[(struct Vec3 *)_66].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _59 = MEM[(struct Vec3 *)_66].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _61 = MEM[(struct Vec3 *)_66].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7678 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _86 = _40 * _92;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _86 = _40 * _92;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _87 = _40 * _93;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e76f8 0x48e7778
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e76f8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _40, _40 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7778 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _92 = _103 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _92 = _103 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _93 = _106 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e77f8 0x48e83f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e77f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _103 = _101 - _102;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _103 = _101 - _102;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _106 = _104 - _105;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7878 0x48e7f78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7878 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _101 = _133 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _101 = _133 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _104 = _136 * _155;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e78f8 0x48e7d78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e78f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7978 0x48e7cf8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7978 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _131 = _155 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _131 = _155 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e79f8 0x48e7b78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e79f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7a78 0x48e7af8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7a78 (max_nunits=2, refcnt=2) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7af8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7b78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7bf8 0x48e7c78
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7bf8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _168 = MEM[(const struct Vec3 *)_172].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7c78 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _169 = MEM[(const struct Vec3 &)_175].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7cf8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _132 = _159 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _132 = _159 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7d78 0x48e7e78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7d78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7bf8 0x48e7df8
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7df8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _158 = MEM[(const struct Vec3 &)_161].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7e78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7a78 0x48e7ef8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7ef8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7f78 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _102 = _136 * _157;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _102 = _136 * _157;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _105 = _130 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7ff8 0x48e80f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7ff8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _130 = _128 - _129;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8078 0x48e8278
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8078 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _128 = _159 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e80f8 0x48e7e78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e80f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8178 0x48e81f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8178 (max_nunits=2, refcnt=2) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _168 = MEM[(const struct Vec3 *)_172].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e81f8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _158 = MEM[(const struct Vec3 &)_161].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8278 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _129 = _157 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e79f8 0x48e82f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e82f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8178 0x48e8378
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8378 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _169 = MEM[(const struct Vec3 &)_175].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e83f8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _100, _100 }
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _59 = MEM[(struct Vec3 *)_66].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_66].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1160_225
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__59.1161_226 = MEM <vector(2) double> [(double *)vectp.1160_225];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1160_186 = vectp.1160_225 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_172].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1163_230
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__162.1164_231 = MEM <const vector(2) double> [(double *)vectp.1163_230];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1163_5 = vectp.1163_230 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_161].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1166_234
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__154.1167_4 = MEM <const vector(2) double> [(double *)vectp.1166_234];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1166_243 = vectp.1166_234 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_172].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_161].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__155.1168_227 = vect__162.1164_231 - vect__154.1167_4;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__170.1169_190 = _76 - _77;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _131 = _155 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _162 - _154, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _168 - _169, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__131.1170_75 = vect__155.1168_227 * vect__170.1169_190;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__159.1171_193 = _76 - _19;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_175].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1173_238
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__163.1174_21 = MEM <const vector(2) double> [(double *)vectp.1173_238];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1173_45 = vectp.1173_238 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_172].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_175].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__164.1175_185 = vect__162.1164_231 - vect__163.1174_21;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _132 = _159 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _168 - _158, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _162 - _163, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__132.1176_184 = vect__159.1171_193 * vect__164.1175_185;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _155 * _170, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _159 * _164, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__133.1177_22 = vect__131.1170_75 - vect__132.1176_184;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _101 = _133 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _131 - _132, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _168 - _158, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__101.1178_233 = vect__133.1177_22 * vect__159.1171_193;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_172].y
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1180_191
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__165.1181_189 = MEM <const vector(2) double> [(double *)vectp.1180_191];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1180_213 = vectp.1180_191 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_161].y
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1183_246
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__156.1184_25 = MEM <const vector(2) double> [(double *)vectp.1183_246];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1183_18 = vectp.1183_246 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_172].y, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_161].y, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__157.1185_9 = vect__165.1181_189 - vect__156.1184_25;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _165 - _156, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _162 - _163, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__134.1186_219 = vect__157.1185_9 * vect__164.1175_185;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_175].y
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1188_218
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__166.1189_217 = MEM <const vector(2) double> [(double *)vectp.1188_218];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1188_216 = vectp.1188_218 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_172].y, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_175].y, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__167.1190_214 = vect__165.1181_189 - vect__166.1189_217;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _162 - _154, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _165 - _166, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__135.1191_202 = vect__155.1168_227 * vect__167.1190_214;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _157 * _164, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _155 * _167, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__136.1192_198 = vect__134.1186_219 - vect__135.1191_202;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _130 = _128 - _129;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _102 = _136 * _157;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _134 - _135, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _165 - _156, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__102.1193_196 = vect__136.1192_198 * vect__157.1185_9;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _103 = _101 - _102;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _133 * _159, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _136 * _157, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__103.1194_195 = vect__101.1178_233 - vect__102.1193_196;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _103 = _101 - _102;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _106 = _104 - _105;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _92 = _103 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _101 - _102, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__92.1195_212 = vect__103.1194_195 / _181;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _86 = _40 * _92;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _103 / _100, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__86.1196_237 = _229 * vect__92.1195_212;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _86 = _40 * _92;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _87 = _40 * _93;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _60 = _59 + _86;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_66].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _40 * _92, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__60.1197_182 = vect__59.1161_226 + vect__86.1196_237;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_66].x = _60;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _59 + _86, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _61 + _87, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_66].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1199_241
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1199_241] = vect__60.1197_182;
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e84f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_74].x = _68;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_74].x = _68;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_74].y = _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8578
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8578 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _68 = _67 - _224;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _68 = _67 - _224;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _70 = _69 - _223;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e85f8 0x48e8678
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e85f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _67 = MEM[(struct Vec3 *)_74].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _67 = MEM[(struct Vec3 *)_74].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _69 = MEM[(struct Vec3 *)_74].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8678 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _224 = _86 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _224 = _86 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _223 = _87 + _90;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7678 0x48e86f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7678 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _86 = _40 * _92;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _86 = _40 * _92;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _87 = _40 * _93;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e76f8 0x48e7778
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e76f8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _40, _40 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7778 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _92 = _103 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _92 = _103 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _93 = _106 / _100;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e77f8 0x48e83f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e77f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _103 = _101 - _102;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _103 = _101 - _102;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _106 = _104 - _105;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7878 0x48e7f78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7878 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _101 = _133 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _101 = _133 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _104 = _136 * _155;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e78f8 0x48e7d78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e78f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7978 0x48e7cf8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7978 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _131 = _155 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _131 = _155 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e79f8 0x48e7b78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e79f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7a78 0x48e7af8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7a78 (max_nunits=2, refcnt=2) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7af8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7b78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7bf8 0x48e7c78
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7bf8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _168 = MEM[(const struct Vec3 *)_172].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7c78 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _169 = MEM[(const struct Vec3 &)_175].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7cf8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _132 = _159 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _132 = _159 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7d78 0x48e7e78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7d78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7bf8 0x48e7df8
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7df8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _158 = MEM[(const struct Vec3 &)_161].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7e78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7a78 0x48e7ef8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7ef8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7f78 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _102 = _136 * _157;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _102 = _136 * _157;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _105 = _130 * _159;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7ff8 0x48e80f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7ff8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _130 = _128 - _129;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8078 0x48e8278
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8078 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _128 = _159 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e80f8 0x48e7e78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e80f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8178 0x48e81f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8178 (max_nunits=2, refcnt=2) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _168 = MEM[(const struct Vec3 *)_172].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e81f8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _158 = MEM[(const struct Vec3 &)_161].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8278 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _129 = _157 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e79f8 0x48e82f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e82f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8178 0x48e8378
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8378 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _169 = MEM[(const struct Vec3 &)_175].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e83f8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _100, _100 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e86f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _89 = _39 * _110;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _89 = _39 * _110;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _90 = _39 * _111;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8778 0x48e87f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e8778 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _39, _39 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e87f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _110 = _121 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _110 = _121 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _111 = _124 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8878 0x48e89f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8878 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _121 = _119 - _120;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _121 = _119 - _120;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _124 = _122 - _123;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e88f8 0x48e8978
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e88f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _119 = _136 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _119 = _136 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _122 = _130 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7ff8 0x48e82f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8978 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _120 = _133 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _120 = _133 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _123 = _136 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e78f8 0x48e7b78
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e89f8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _118, _118 }
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _67 = MEM[(struct Vec3 *)_74].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_74].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1201_249
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__67.1202_250 = MEM <vector(2) double> [(double *)vectp.1201_249];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1201_251 = vectp.1201_249 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _119 = _136 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _134 - _135, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _165 - _166, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__119.1203_253 = vect__136.1192_198 * vect__167.1190_214;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _120 = _133 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _131 - _132, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _168 - _169, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__120.1204_254 = vect__133.1177_22 * vect__170.1169_190;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _121 = _119 - _120;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _136 * _167, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _133 * _170, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__121.1205_255 = vect__119.1203_253 - vect__120.1204_254;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _121 = _119 - _120;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _124 = _122 - _123;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _110 = _121 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _119 - _120, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__110.1206_259 = vect__121.1205_255 / _258;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _89 = _39 * _110;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _121 / _118, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__89.1207_260 = _252 * vect__110.1206_259;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _89 = _39 * _110;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _90 = _39 * _111;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _224 = _86 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _40 * _92, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _39 * _110, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__224.1208_263 = vect__86.1196_237 + vect__89.1207_260;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _68 = _67 - _224;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_74].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _86 + _89, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__68.1209_264 = vect__67.1202_250 - vect__224.1208_263;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_74].x = _68;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _67 - _224, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _69 - _223, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_74].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1211_265
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1211_265] = vect__68.1209_264;
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8af8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_85].x = _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_85].x = _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_85].y = _81;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8b78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8b78 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _79 = _78 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _79 = _78 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _81 = _80 + _90;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8bf8 0x48e86f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8bf8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _78 = MEM[(struct Vec3 *)_85].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _78 = MEM[(struct Vec3 *)_85].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _80 = MEM[(struct Vec3 *)_85].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e86f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _89 = _39 * _110;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _89 = _39 * _110;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _90 = _39 * _111;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8778 0x48e87f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e8778 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _39, _39 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e87f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _110 = _121 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _110 = _121 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _111 = _124 / _118;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8878 0x48e89f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8878 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _121 = _119 - _120;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _121 = _119 - _120;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _124 = _122 - _123;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e88f8 0x48e8978
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e88f8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _119 = _136 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _119 = _136 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _122 = _130 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7ff8 0x48e82f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7ff8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _130 = _128 - _129;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8078 0x48e8278
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8078 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _128 = _159 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e80f8 0x48e7e78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e80f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8178 0x48e81f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8178 (max_nunits=2, refcnt=2) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _168 = MEM[(const struct Vec3 *)_172].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e81f8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _158 = MEM[(const struct Vec3 &)_161].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7e78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7a78 0x48e7ef8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7a78 (max_nunits=2, refcnt=2) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _165 = MEM[(const struct Vec3 *)_172].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7ef8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8278 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _129 = _157 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e79f8 0x48e82f8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e79f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _157 = _165 - _156;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7a78 0x48e7af8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7af8 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _156 = MEM[(const struct Vec3 &)_161].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e82f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _167 = _165 - _166;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e8178 0x48e8378
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8378 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _166 = MEM[(const struct Vec3 &)_175].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _169 = MEM[(const struct Vec3 &)_175].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e8978 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _120 = _133 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _120 = _133 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _123 = _136 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e78f8 0x48e7b78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e78f8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _133 = _131 - _132;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _136 = _134 - _135;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7978 0x48e7cf8
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7978 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _131 = _155 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _131 = _155 * _170;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _134 = _157 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e79f8 0x48e7b78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7b78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _170 = _168 - _169;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _164 = _162 - _163;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7bf8 0x48e7c78
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7bf8 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _168 = MEM[(const struct Vec3 *)_172].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _162 = MEM[(const struct Vec3 *)_172].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7c78 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _169 = MEM[(const struct Vec3 &)_175].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _163 = MEM[(const struct Vec3 &)_175].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7cf8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _132 = _159 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _132 = _159 * _164;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _135 = _155 * _167;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7d78 0x48e7e78
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48e7d78 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _159 = _168 - _158;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _155 = _162 - _154;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48e7bf8 0x48e7df8
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e7df8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _158 = MEM[(const struct Vec3 &)_161].z;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _154 = MEM[(const struct Vec3 &)_161].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48e89f8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _118, _118 }
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _78 = MEM[(struct Vec3 *)_85].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_85].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1213_267
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__78.1214_268 = MEM <vector(2) double> [(double *)vectp.1213_267];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1213_269 = vectp.1213_267 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _79 = _78 + _89;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_85].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _39 * _110, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__79.1215_270 = vect__78.1214_268 + vect__89.1207_260;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_85].x = _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _78 + _89, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _80 + _90, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_85].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1217_271
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1217_271] = vect__79.1215_270;
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:41:11: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:282:26: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:282:26: missed: not vectorized: multiple nested loops.
task3_variants/vec_all_pragmas.cpp:283:36: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:283:36: missed: not vectorized: multiple nested loops.
task3_variants/vec_all_pragmas.cpp:284:26: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:284:26: missed: not vectorized: control flow in loop.
task3_variants/vec_all_pragmas.cpp:285:26: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:41:11: missed: not vectorized: complicated access pattern.
task3_variants/vec_all_pragmas.cpp:278:6: note: vectorized 0 loops in function.
task3_variants/vec_all_pragmas.cpp:41:11: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:41:11: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:41:11: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874798 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_61].x = _55;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_61].x = _55;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_61].y = _57;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874818
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874818 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _55 = _54 - _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _55 = _54 - _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _57 = _56 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874898 0x4874918
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874898 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _54 = MEM[(struct Vec3 *)_61].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _54 = MEM[(struct Vec3 *)_61].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _56 = MEM[(struct Vec3 *)_61].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874918 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _70 = _21 * _80;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _70 = _21 * _80;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _71 = _21 * _83;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874998 0x4874a18
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x4874998 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _21, _21 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874a18 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _80 = _78 - _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _80 = _78 - _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _83 = _81 - _82;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874a98 0x4874b18
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874a98 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _78 = MEM[(const struct Vec3 *)_88].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _78 = MEM[(const struct Vec3 *)_88].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _81 = MEM[(const struct Vec3 *)_88].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874b18 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _79 = MEM[(const struct Vec3 &)_91].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _79 = MEM[(const struct Vec3 &)_91].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _82 = MEM[(const struct Vec3 &)_91].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874c18 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_69].x = _63;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_69].x = _63;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_69].y = _65;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874c98
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874c98 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _63 = _62 + _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _63 = _62 + _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _65 = _64 + _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874d18 0x4874918
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874d18 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _62 = MEM[(struct Vec3 *)_69].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _62 = MEM[(struct Vec3 *)_69].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _64 = MEM[(struct Vec3 *)_69].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis for part in loop 4:
  Vector cost: 148
  Scalar cost: 256
task3_variants/vec_all_pragmas.cpp:41:11: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874798 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_61].x = _55;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_61].x = _55;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_61].y = _57;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874818
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874818 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _55 = _54 - _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _55 = _54 - _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _57 = _56 - _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874898 0x4874918
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874898 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _54 = MEM[(struct Vec3 *)_61].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _54 = MEM[(struct Vec3 *)_61].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _56 = MEM[(struct Vec3 *)_61].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874918 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _70 = _21 * _80;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _70 = _21 * _80;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _71 = _21 * _83;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874998 0x4874a18
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x4874998 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _21, _21 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874a18 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _80 = _78 - _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _80 = _78 - _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _83 = _81 - _82;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874a98 0x4874b18
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874a98 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _78 = MEM[(const struct Vec3 *)_88].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _78 = MEM[(const struct Vec3 *)_88].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _81 = MEM[(const struct Vec3 *)_88].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874b18 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _79 = MEM[(const struct Vec3 &)_91].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _79 = MEM[(const struct Vec3 &)_91].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _82 = MEM[(const struct Vec3 &)_91].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _54 = MEM[(struct Vec3 *)_61].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_61].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1240_315
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__54.1241_314 = MEM <vector(2) double> [(double *)vectp.1240_315];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1240_313 = vectp.1240_315 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _78 = MEM[(const struct Vec3 *)_88].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_88].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1243_311
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__78.1244_310 = MEM <const vector(2) double> [(double *)vectp.1243_311];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1243_309 = vectp.1243_311 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _79 = MEM[(const struct Vec3 &)_91].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 &)_91].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1246_308
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__79.1247_307 = MEM <const vector(2) double> [(double *)vectp.1246_308];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1246_306 = vectp.1246_308 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _80 = _78 - _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_88].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 &)_91].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__80.1248_305 = vect__78.1244_310 - vect__79.1247_307;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _80 = _78 - _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _83 = _81 - _82;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _70 = _21 * _80;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _78 - _79, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__70.1249_302 = _312 * vect__80.1248_305;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _70 = _21 * _80;
task3_variants/vec_all_pragmas.cpp:41:11: note: extracting lane for live stmt _71 = _21 * _83;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _55 = _54 - _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_61].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _21 * _80, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__55.1250_299 = vect__54.1241_314 - vect__70.1249_302;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_61].x = _55;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _54 - _70, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _56 - _71, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_61].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1252_298
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1252_298] = vect__55.1250_299;
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874c18 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_69].x = _63;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_69].x = _63;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_69].y = _65;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874c98
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874c98 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _63 = _62 + _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _63 = _62 + _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _65 = _64 + _71;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874d18 0x4874918
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874d18 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _62 = MEM[(struct Vec3 *)_69].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _62 = MEM[(struct Vec3 *)_69].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _64 = MEM[(struct Vec3 *)_69].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874918 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _70 = _21 * _80;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _70 = _21 * _80;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _71 = _21 * _83;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874998 0x4874a18
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x4874998 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _21, _21 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874a18 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _80 = _78 - _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _80 = _78 - _79;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _83 = _81 - _82;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4874a98 0x4874b18
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874a98 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _78 = MEM[(const struct Vec3 *)_88].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _78 = MEM[(const struct Vec3 *)_88].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _81 = MEM[(const struct Vec3 *)_88].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4874b18 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _79 = MEM[(const struct Vec3 &)_91].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _79 = MEM[(const struct Vec3 &)_91].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _82 = MEM[(const struct Vec3 &)_91].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _62 = MEM[(struct Vec3 *)_69].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_69].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1254_296
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__62.1255_295 = MEM <vector(2) double> [(double *)vectp.1254_296];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1254_294 = vectp.1254_296 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _63 = _62 + _70;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_69].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _21 * _80, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__63.1256_293 = vect__62.1255_295 + vect__70.1249_302;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_69].x = _63;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _62 + _70, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _64 + _71, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_69].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1258_292
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1258_292] = vect__63.1256_293;
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:41:11: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:311:27: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:316:24: missed: not vectorized: more than one data ref in stmt: *_53 = D.112315[_15];
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:316:24: missed: not vectorized: more than one data ref in stmt: *_53 = D.112315[_15];
task3_variants/vec_all_pragmas.cpp:308:6: note: vectorized 0 loops in function.
task3_variants/vec_all_pragmas.cpp:316:24: missed: not vectorized: more than one data ref in stmt: *_53 = D.112315[0];
task3_variants/vec_all_pragmas.cpp:41:11: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:41:11: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:41:11: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48847a8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_44].x = _38;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_44].x = _38;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_44].y = _40;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4884828
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884828 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _38 = _37 + _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _38 = _37 + _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _40 = _39 + _48;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48848a8 0x4884928
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48848a8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _37 = MEM[(struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _37 = MEM[(struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _39 = MEM[(struct Vec3 *)_44].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884928 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _46 = _19 * _45;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _46 = _19 * _45;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _48 = _19 * _47;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48849a8 0x4884a28
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48849a8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _19, _19 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884a28 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _45 = MEM[(const struct Vec3 *)_53].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _45 = MEM[(const struct Vec3 *)_53].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _47 = MEM[(const struct Vec3 *)_53].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis for part in loop 2:
  Vector cost: 68
  Scalar cost: 128
task3_variants/vec_all_pragmas.cpp:21:41: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:21:41: note: node 0x4884b28 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: op template: MEM <struct Vec3[32]> [(struct Vec3 *)&D.112315][0].x = 0.0;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 0 MEM <struct Vec3[32]> [(struct Vec3 *)&D.112315][0].x = 0.0;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	stmt 1 MEM <struct Vec3[32]> [(struct Vec3 *)&D.112315][0].y = 0.0;
task3_variants/vec_all_pragmas.cpp:21:41: note: 	children 0x4884ba8
task3_variants/vec_all_pragmas.cpp:21:41: note: node (constant) 0x4884ba8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:21:41: note: 	{ 0.0, 0.0 }
task3_variants/vec_all_pragmas.cpp:21:41: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:21:41: note: Cost model analysis for part in loop 2:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:41:11: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884ca8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_30].x = _16;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_30].x = _16;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_30].y = _26;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4884d28
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884d28 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _16 = _20 + _32;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _16 = _20 + _32;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _26 = _12 + _34;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4884da8 0x4884e28
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884da8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _20 = MEM[(struct Vec3 *)_30].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _20 = MEM[(struct Vec3 *)_30].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _12 = MEM[(struct Vec3 *)_30].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884e28 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _32 = _22 * _31;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _32 = _22 * _31;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _34 = _22 * _33;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4884ea8 0x4884f28
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x4884ea8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _22, _22 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884f28 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _31 = MEM[(const struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _31 = MEM[(const struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _33 = MEM[(const struct Vec3 *)_44].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:41:11: note: Cost model analysis for part in loop 2:
  Vector cost: 68
  Scalar cost: 128
task3_variants/vec_all_pragmas.cpp:41:11: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48847a8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_44].x = _38;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_44].x = _38;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_44].y = _40;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4884828
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884828 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _38 = _37 + _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _38 = _37 + _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _40 = _39 + _48;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48848a8 0x4884928
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x48848a8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _37 = MEM[(struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _37 = MEM[(struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _39 = MEM[(struct Vec3 *)_44].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884928 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _46 = _19 * _45;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _46 = _19 * _45;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _48 = _19 * _47;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x48849a8 0x4884a28
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x48849a8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _19, _19 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884a28 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _45 = MEM[(const struct Vec3 *)_53].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _45 = MEM[(const struct Vec3 *)_53].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _47 = MEM[(const struct Vec3 *)_53].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _37 = MEM[(struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_44].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1288_15
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__37.1289_73 = MEM <vector(2) double> [(double *)vectp.1288_15];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1288_66 = vectp.1288_15 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _45 = MEM[(const struct Vec3 *)_53].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_53].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1291_57
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__45.1292_55 = MEM <const vector(2) double> [(double *)vectp.1291_57];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1291_6 = vectp.1291_57 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _46 = _19 * _45;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_53].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__46.1293_5 = _72 * vect__45.1292_55;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _38 = _37 + _46;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_44].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _19 * _45, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__38.1294_4 = vect__37.1289_73 + vect__46.1293_5;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_44].x = _38;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _37 + _46, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _39 + _48, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_44].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1296_75
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1296_75] = vect__38.1294_4;
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884b28 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM <struct Vec3[32]> [(struct Vec3 *)&D.112315][0].x = 0.0;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM <struct Vec3[32]> [(struct Vec3 *)&D.112315][0].x = 0.0;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM <struct Vec3[32]> [(struct Vec3 *)&D.112315][0].y = 0.0;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4884ba8
task3_variants/vec_all_pragmas.cpp:41:11: note: node (constant) 0x4884ba8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ 0.0, 0.0 }
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM <struct Vec3[32]> [(struct Vec3 *)&D.112315][0].x = 0.0;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand 0.0, type of def: constant
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM <struct Vec3[32]> [(struct Vec3 *)&D.112315][0].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created &MEM <struct Vec3[32]> [(struct Vec3 *)&D.112315][0]
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(struct Vec3 *)&D.112315] = { 0.0, 0.0 };
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:41:11: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884ca8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: MEM[(struct Vec3 *)_30].x = _16;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 MEM[(struct Vec3 *)_30].x = _16;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 MEM[(struct Vec3 *)_30].y = _26;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4884d28
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884d28 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _16 = _20 + _32;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _16 = _20 + _32;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _26 = _12 + _34;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4884da8 0x4884e28
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884da8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _20 = MEM[(struct Vec3 *)_30].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _20 = MEM[(struct Vec3 *)_30].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _12 = MEM[(struct Vec3 *)_30].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884e28 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _32 = _22 * _31;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _32 = _22 * _31;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _34 = _22 * _33;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	children 0x4884ea8 0x4884f28
task3_variants/vec_all_pragmas.cpp:41:11: note: node (external) 0x4884ea8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: 	{ _22, _22 }
task3_variants/vec_all_pragmas.cpp:41:11: note: node 0x4884f28 (max_nunits=2, refcnt=1) const vector(2) double
task3_variants/vec_all_pragmas.cpp:41:11: note: op template: _31 = MEM[(const struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 0 _31 = MEM[(const struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: 	stmt 1 _33 = MEM[(const struct Vec3 *)_44].y;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _20 = MEM[(struct Vec3 *)_30].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_30].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1300_78
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__20.1301_79 = MEM <vector(2) double> [(double *)vectp.1300_78];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1300_80 = vectp.1300_78 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _31 = MEM[(const struct Vec3 *)_44].x;
task3_variants/vec_all_pragmas.cpp:41:11: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: const vector(2) double  vectorizing a pointer ref: MEM[(const struct Vec3 *)_44].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1303_82
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__31.1304_83 = MEM <const vector(2) double> [(double *)vectp.1303_82];
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vectp.1303_84 = vectp.1303_82 + 8;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _32 = _22 * _31;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(const struct Vec3 *)_44].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__32.1305_85 = _81 * vect__31.1304_83;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: _16 = _20 + _32;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand MEM[(struct Vec3 *)_30].x, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _22 * _31, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform binary/unary operation.
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: vect__16.1306_86 = vect__20.1301_79 + vect__32.1305_85;
task3_variants/vec_all_pragmas.cpp:41:11: note: ------>vectorizing SLP node starting from: MEM[(struct Vec3 *)_30].x = _16;
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _20 + _32, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: vect_is_simple_use: operand _12 + _34, type of def: internal
task3_variants/vec_all_pragmas.cpp:41:11: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:41:11: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: MEM[(struct Vec3 *)_30].x
task3_variants/vec_all_pragmas.cpp:41:11: note: created vectp.1308_87
task3_variants/vec_all_pragmas.cpp:41:11: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1308_87] = vect__16.1306_86;
task3_variants/vec_all_pragmas.cpp:41:11: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:41:11: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:41:11: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_37, _42);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_29, _43);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_21, _44);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_12, _15);
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
task3_variants/vec_all_pragmas.cpp:368:26: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:368:26: missed: not vectorized: control flow in loop.
task3_variants/vec_all_pragmas.cpp:368:26: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:368:26: missed: not vectorized: control flow in loop.
task3_variants/vec_all_pragmas.cpp:364:6: note: vectorized 0 loops in function.
/usr/include/c++/13/ostream:223:25: missed: statement clobbers memory: _31 = std::basic_ostream<char>::_M_insert<double> (_1, _2);
/usr/include/c++/13/ostream:667:18: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_31, " ", 1);
/usr/include/c++/13/bits/basic_string.h:4037:30: missed: statement clobbers memory: _30 = std::__ostream_insert<char, std::char_traits<char> > (_31, _29, _28);
/usr/include/c++/13/ostream:667:18: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_30, " ", 1);
/usr/include/c++/13/ostream:223:25: missed: statement clobbers memory: _23 = std::basic_ostream<char>::_M_insert<double> (_30, _3);
/usr/include/c++/13/ostream:667:18: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_23, " ", 1);
/usr/include/c++/13/ostream:223:25: missed: statement clobbers memory: _20 = std::basic_ostream<char>::_M_insert<double> (_23, _4);
/usr/include/c++/13/ostream:667:18: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_20, " ", 1);
/usr/include/c++/13/ostream:223:25: missed: statement clobbers memory: _13 = std::basic_ostream<char>::_M_insert<double> (_20, _5);
/usr/include/c++/13/ostream:574:16: missed: statement clobbers memory: std::basic_ostream<char>::put (_13, 10);
/usr/include/c++/13/ostream:573:25: missed: statement clobbers memory: std::__ostream_insert<char, std::char_traits<char> > (_13, &__c, 1);
task3_variants/vec_all_pragmas.cpp:375:1: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:375:1: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_7, _15);
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_vector.h:733:7: note: vectorized 0 loops in function.
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_46, _51);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_38, _52);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_30, _53);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_21, _24);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_14, _55);
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_7, _15);
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_7, _15);
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
task3_variants/vec_all_pragmas.cpp:346:26: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:346:26: missed: not vectorized: latch block not empty.
task3_variants/vec_all_pragmas.cpp:341:68: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:341:68: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_uninitialized.h:642:19: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:642:19: optimized: loop vectorized using 16 byte vectors
task3_variants/vec_all_pragmas.cpp:109:7: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:109:7: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1726 = *__first$_M_current_2422;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2420 = *__first$_M_current_2419;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1771 = *__first$_M_current_1719;
task3_variants/vec_all_pragmas.cpp:109:7: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:109:7: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1486 = *__first$_M_current_1484;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1708 = *__first$_M_current_2664;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1491 = *__first$_M_current_1512;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1748 = *__first$_M_current_1684;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2132 = *__first$_M_current_2131;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1675 = *__first$_M_current_1673;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_72 = *__first$_M_current_71;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1668 = *__first$_M_current_2088;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_61 = *__first$_M_current_2203;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2247 = *__first$_M_current_2291;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2317 = *__first$_M_current_1640;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1774 = *__first$_M_current_1618;
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_uninitialized.h:266:15: optimized: loop vectorized using 16 byte vectors
task3_variants/vec_all_pragmas.cpp:324:8: note: vectorized 10 loops in function.
task3_variants/vec_all_pragmas.cpp:324:8: missed: splitting region at control altering definition _219 = operator new (_218);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _219 = operator new (_218);
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: SLPing BB part
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&O + 49] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x4833e38
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 79, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:119:7: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:119:7: note: node 0x4833eb8 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:119:7: note: op template: O.mass = 1.6e+1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 0 O.mass = 1.6e+1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 1 O.ep = 6.5000000000000002220446049250313080847263336181640625e-1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 2 O.sigma = 3.09999999999999997779553950749686919152736663818359375e-1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 3 O.charge = -8.1999999999999995115018691649311222136020660400390625e-1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	children 0x4833f38
task3_variants/vec_all_pragmas.cpp:119:7: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:119:7: note: 	{ 1.6e+1, 6.5000000000000002220446049250313080847263336181640625e-1, 3.09999999999999997779553950749686919152736663818359375e-1, -8.1999999999999995115018691649311222136020660400390625e-1 }
task3_variants/vec_all_pragmas.cpp:119:7: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 64
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x4833fb8 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&D.98945 + 16] = 79;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&D.98945 + 16] = 79;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&D.98945 + 17] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x4834038
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x4834038 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 79, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x48341b8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x48341b8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x48342b8 (max_nunits=4, refcnt=1) vector(4) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&O + 64B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 2 MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.92419._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 3 MEM[(struct _Vector_base *)&O + 88B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(4) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B, 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 64
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: op template: MEM[(struct vector *)&O + 88B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 0 MEM[(struct vector *)&O + 88B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 1 MEM[(struct _Vector_base *)&O + 88B]._M_impl.D.92419._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	children 0x48344b8
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: op template: MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 0 MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 1 MEM[(char_type &)&O + 49] = 0;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	{ 79, 0 }
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&O + 48] = 79;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&O + 48]
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: created &MEM[(char_type &)&O + 48]
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: add new stmt: MEM <vector(2) char> [(char_type &)&O + 48] = { 79, 0 };
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:1706:26: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node 0x4833eb8 (max_nunits=4, refcnt=1) vector(4) double
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: op template: O.mass = 1.6e+1;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 0 O.mass = 1.6e+1;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 1 O.ep = 6.5000000000000002220446049250313080847263336181640625e-1;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 2 O.sigma = 3.09999999999999997779553950749686919152736663818359375e-1;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 3 O.charge = -8.1999999999999995115018691649311222136020660400390625e-1;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(4) double
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	{ 1.6e+1, 6.5000000000000002220446049250313080847263336181640625e-1, 3.09999999999999997779553950749686919152736663818359375e-1, -8.1999999999999995115018691649311222136020660400390625e-1 }
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: ------>vectorizing SLP node starting from: O.mass = 1.6e+1;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand 6.5000000000000002220446049250313080847263336181640625e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand 3.09999999999999997779553950749686919152736663818359375e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand -8.1999999999999995115018691649311222136020660400390625e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: create vector_type-pointer variable to type: vector(4) double  vectorizing a pointer ref: O.mass
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: created &O
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: add new stmt: MEM <vector(4) double> [(double *)&O] = { 1.6e+1, 6.5000000000000002220446049250313080847263336181640625e-1, 3.09999999999999997779553950749686919152736663818359375e-1, -8.1999999999999995115018691649311222136020660400390625e-1 };
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:1706:26: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node 0x4833fb8 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: op template: MEM[(char_type &)&D.98945 + 16] = 79;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 0 MEM[(char_type &)&D.98945 + 16] = 79;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 1 MEM[(char_type &)&D.98945 + 17] = 0;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	children 0x4834038
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node (constant) 0x4834038 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	{ 79, 0 }
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&D.98945 + 16] = 79;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&D.98945 + 16]
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: created &MEM[(char_type &)&D.98945 + 16]
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: add new stmt: MEM <vector(2) char> [(char_type &)&D.98945 + 16] = { 79, 0 };
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:1706:26: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: op template: MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	children 0x48341b8
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node (constant) 0x48341b8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&O + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&O + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: created &MEM[(struct _Vector_impl_data *)&O + 64B]
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:1706:26: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node 0x48342b8 (max_nunits=4, refcnt=1) vector(4) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: op template: MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 0 MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 1 MEM[(struct vector *)&O + 64B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 2 MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.92419._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 3 MEM[(struct _Vector_base *)&O + 88B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(4) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	{ 0B, 0B, 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: create vector_type-pointer variable to type: vector(4) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_base *)&O + 64B]._M_impl.D.92419._M_start
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: created &MEM[(struct _Vector_base *)&O + 64B]
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: add new stmt: MEM <vector(4) long unsigned int> [(struct Vec3 * *)&O + 64B] = { 0, 0, 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:1706:26: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: op template: MEM[(struct vector *)&O + 88B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 0 MEM[(struct vector *)&O + 88B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	stmt 1 MEM[(struct _Vector_base *)&O + 88B]._M_impl.D.92419._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	children 0x48344b8
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: ------>vectorizing SLP node starting from: MEM[(struct vector *)&O + 88B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct vector *)&O + 88B].D.93080._M_impl.D.92419._M_finish
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: created &MEM[(struct vector *)&O + 88B].D.93080._M_impl.D.92419._M_finish
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 96B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:1706:26: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:1706:26: missed: splitting region at dominance boundary bb8
/usr/include/c++/13/bits/stl_vector.h:1706:26: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1706:26: missed: splitting region at control altering definition _588 = operator new (_218);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _588 = operator new (_218);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x48344b8 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_217->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_217->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_217->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x48342b8
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x48342b8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x48341b8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x48341b8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x48344b8 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_217->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_217->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_217->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x48342b8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x48342b8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_217->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_217->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1594_195
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1594_195] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x48341b8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x48341b8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&O + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&O + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&O + 88B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 88B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb11
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _223 = operator new (_218);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _223 = operator new (_218);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x48341b8 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1429->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1429->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1429->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x48344b8
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x48341b8 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_1429->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_1429->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_1429->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x48344b8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_1429->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1429->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1598_1289
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1598_1289] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&O + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&O + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&O + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&O + 112B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&O + 112B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb21
task3_variants/vec_all_pragmas.cpp:121:6: missed: statement clobbers memory: std::vector<Vec3>::~vector (&O.v);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 86
task3_variants/vec_all_pragmas.cpp:121:6: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:121:6: missed: splitting region at dominance boundary bb14
task3_variants/vec_all_pragmas.cpp:121:6: missed: statement clobbers memory: std::vector<Vec3>::~vector (&O.p);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 85
task3_variants/vec_all_pragmas.cpp:121:6: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:121:6: missed: splitting region at dominance boundary bb17
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_construct.h:119:7: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1319->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1319->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1319->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x48341b8
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x48341b8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1319->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1319->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1319->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x48341b8
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x48341b8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ------>vectorizing SLP node starting from: __cur_1319->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_construct.h:119:7: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_construct.h:119:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1319->x
/usr/include/c++/13/bits/stl_construct.h:119:7: note: created vectp.1602_1426
/usr/include/c++/13/bits/stl_construct.h:119:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1602_1426] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_construct.h:119:7: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: splitting region at control altering definition _1646 = operator new (_2080);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_2391, _260);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1646 = operator new (_2080);
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:398:25: note: SLPing BB part
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&H1 + 49] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x48341b8
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x48341b8 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 72, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:119:7: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:119:7: note: node 0x4834438 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:119:7: note: op template: H1.mass = 1.0e+0;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 0 H1.mass = 1.0e+0;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 1 H1.ep = 1.882800000000000029132252166164107620716094970703125e-1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 2 H1.sigma = 2.37999999999999989341858963598497211933135986328125e-1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 3 H1.charge = 4.09999999999999975575093458246556110680103302001953125e-1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	children 0x48344b8
task3_variants/vec_all_pragmas.cpp:119:7: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:119:7: note: 	{ 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 }
task3_variants/vec_all_pragmas.cpp:119:7: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 64
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833fb8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x4834038 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&D.98960 + 16] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&D.98960 + 16] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&D.98960 + 17] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x4833eb8
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x4833eb8 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 72, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&H1 + 64B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&H1 + 49] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x48341b8
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x48341b8 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 72, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&H1 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&H1 + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&H1 + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&H1 + 48] = { 72, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4834438 (max_nunits=4, refcnt=1) vector(4) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: H1.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 H1.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 H1.ep = 1.882800000000000029132252166164107620716094970703125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 2 H1.sigma = 2.37999999999999989341858963598497211933135986328125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 3 H1.charge = 4.09999999999999975575093458246556110680103302001953125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x48344b8
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(4) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: H1.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 1.882800000000000029132252166164107620716094970703125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 2.37999999999999989341858963598497211933135986328125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 4.09999999999999975575093458246556110680103302001953125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(4) double  vectorizing a pointer ref: H1.mass
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &H1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(4) double> [(double *)&H1] = { 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4833fb8
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H1 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_impl_data *)&H1 + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H1 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4834038 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&D.98960 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&D.98960 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&D.98960 + 17] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4833eb8
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4833eb8 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 72, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&D.98960 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&D.98960 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&D.98960 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&D.98960 + 16] = { 72, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&H1 + 64B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_base *)&H1 + 64B]._M_impl.D.92419._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_base *)&H1 + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H1 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at dominance boundary bb29
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at control altering definition _1494 = operator new (_2080);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1494 = operator new (_2080);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1910->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1910->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1910->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x4834038
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x4834038 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833fb8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_1910->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_1910->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_1910->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834038
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834038 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_1910->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1910->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1614_1315
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1614_1315] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833fb8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H1 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&H1 + 88B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H1 + 88B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _1396 = operator new (_2080);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1396 = operator new (_2080);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4833fb8 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_529->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_529->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_529->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833eb8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833db8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833db8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833fb8 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_529->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_529->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_529->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_529->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_529->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1618_968
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1618_968] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833eb8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833db8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833db8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H1 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&H1 + 112B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H1 + 112B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb42
task3_variants/vec_all_pragmas.cpp:121:6: missed: statement clobbers memory: std::vector<Vec3>::~vector (&H1.v);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 89
task3_variants/vec_all_pragmas.cpp:121:6: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:121:6: missed: splitting region at dominance boundary bb45
task3_variants/vec_all_pragmas.cpp:121:6: missed: statement clobbers memory: std::vector<Vec3>::~vector (&H1.p);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 88
task3_variants/vec_all_pragmas.cpp:121:6: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:121:6: missed: splitting region at dominance boundary bb35
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&H1.name);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 87
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&D.98960);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 14
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb38
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_construct.h:119:7: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1025->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1025->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1025->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x4833fb8
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_1025->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_1025->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_1025->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x4833fb8
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ------>vectorizing SLP node starting from: __cur_1025->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_construct.h:119:7: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_construct.h:119:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_1025->x
/usr/include/c++/13/bits/stl_construct.h:119:7: note: created vectp.1622_1141
/usr/include/c++/13/bits/stl_construct.h:119:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1622_1141] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_construct.h:119:7: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: splitting region at control altering definition _1876 = operator new (_2080);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_1728, _347);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1876 = operator new (_2080);
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:398:25: note: SLPing BB part
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&H2 + 49] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x4833fb8
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 72, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:119:7: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:119:7: note: node 0x4833eb8 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:119:7: note: op template: H2.mass = 1.0e+0;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 0 H2.mass = 1.0e+0;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 1 H2.ep = 1.882800000000000029132252166164107620716094970703125e-1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 2 H2.sigma = 2.37999999999999989341858963598497211933135986328125e-1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	stmt 3 H2.charge = 4.09999999999999975575093458246556110680103302001953125e-1;
task3_variants/vec_all_pragmas.cpp:119:7: note: 	children 0x4833e38
task3_variants/vec_all_pragmas.cpp:119:7: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:119:7: note: 	{ 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 }
task3_variants/vec_all_pragmas.cpp:119:7: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 64
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/char_traits.h:358:7: note: Costing subgraph: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: node 0x48344b8 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: op template: MEM[(char_type &)&D.98963 + 16] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 0 MEM[(char_type &)&D.98963 + 16] = 72;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	stmt 1 MEM[(char_type &)&D.98963 + 17] = 0;
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	children 0x4834338
/usr/include/c++/13/bits/char_traits.h:358:7: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/char_traits.h:358:7: note: 	{ 72, 0 }
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis: 
/usr/include/c++/13/bits/char_traits.h:358:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&H2 + 64B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4834238
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4834238 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&H2 + 49] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4833fb8
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 72, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&H2 + 48] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&H2 + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&H2 + 48]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&H2 + 48] = { 72, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4833eb8 (max_nunits=4, refcnt=1) vector(4) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: H2.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 H2.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 H2.ep = 1.882800000000000029132252166164107620716094970703125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 2 H2.sigma = 2.37999999999999989341858963598497211933135986328125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 3 H2.charge = 4.09999999999999975575093458246556110680103302001953125e-1;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(4) double
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: H2.mass = 1.0e+0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 1.882800000000000029132252166164107620716094970703125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 2.37999999999999989341858963598497211933135986328125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 4.09999999999999975575093458246556110680103302001953125e-1, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(4) double  vectorizing a pointer ref: H2.mass
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &H2
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(4) double> [(double *)&H2] = { 1.0e+0, 1.882800000000000029132252166164107620716094970703125e-1, 2.37999999999999989341858963598497211933135986328125e-1, 4.09999999999999975575093458246556110680103302001953125e-1 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H2 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_impl_data *)&H2 + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H2 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x48344b8 (max_nunits=2, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(char_type &)&D.98963 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(char_type &)&D.98963 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(char_type &)&D.98963 + 17] = 0;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) char
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 72, 0 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(char_type &)&D.98963 + 16] = 72;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) char  vectorizing a pointer ref: MEM[(char_type &)&D.98963 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(char_type &)&D.98963 + 16]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) char> [(char_type &)&D.98963 + 16] = { 72, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct vector *)&H2 + 64B].D.93080._M_impl.D.92419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4834238
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x4834238 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.92419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_base *)&H2 + 64B]._M_impl.D.92419._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_base *)&H2 + 64B]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H2 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at dominance boundary bb50
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at control altering definition _1972 = operator new (_2080);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1972 = operator new (_2080);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4834238 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_600->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_600->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_600->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x48344b8
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834238 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_600->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_600->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_600->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x48344b8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_600->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_600->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1634_531
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1634_531] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H2 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&H2 + 88B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H2 + 88B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb53
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _2066 = operator new (_2080);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _2066 = operator new (_2080);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_316->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_316->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_316->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x4834238
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x4834238 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: __cur_316->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 __cur_316->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 __cur_316->y = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834238
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834238 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: __cur_316->x = 0.0;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_316->x
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1638_825
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1638_825] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&H2 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&H2 + 112B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&H2 + 112B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb63
task3_variants/vec_all_pragmas.cpp:121:6: missed: statement clobbers memory: std::vector<Vec3>::~vector (&H2.v);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 92
task3_variants/vec_all_pragmas.cpp:121:6: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:121:6: missed: splitting region at dominance boundary bb66
task3_variants/vec_all_pragmas.cpp:121:6: missed: statement clobbers memory: std::vector<Vec3>::~vector (&H2.p);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 91
task3_variants/vec_all_pragmas.cpp:121:6: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:121:6: missed: splitting region at dominance boundary bb56
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&H2.name);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 90
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&D.98963);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 23
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb59
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_construct.h:119:7: note: SLPing BB part
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_765->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_765->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_765->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_construct.h:119:7: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: op template: __cur_765->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 0 __cur_765->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	stmt 1 __cur_765->y = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_construct.h:119:7: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_construct.h:119:7: note: 	{ 0.0, 0.0 }
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ------>vectorizing SLP node starting from: __cur_765->x = 0.0;
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vect_is_simple_use: operand 0.0, type of def: constant
/usr/include/c++/13/bits/stl_construct.h:119:7: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_construct.h:119:7: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: __cur_765->x
/usr/include/c++/13/bits/stl_construct.h:119:7: note: created vectp.1642_1068
/usr/include/c++/13/bits/stl_construct.h:119:7: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1642_1068] = { 0.0, 0.0 };
/usr/include/c++/13/bits/stl_construct.h:119:7: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_construct.h:119:7: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_construct.h:119:7: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: splitting region at control altering definition _460 = operator new (64);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_1191, _441);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _460 = operator new (64);
task3_variants/vec_all_pragmas.cpp:335:5: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:335:5: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: op template: MEM[(struct _Vector_impl_data *)&waterbonds]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&waterbonds]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&waterbonds]._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:335:5: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:335:5: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:335:5: note: op template: D.98976[0].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 0 D.98976[0].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 1 D.98976[0].L0 = 9.583999999999999463984323710974422283470630645751953125e-2;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	children 0x4834238
task3_variants/vec_all_pragmas.cpp:335:5: note: node (constant) 0x4834238 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:335:5: note: 	{ 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 }
task3_variants/vec_all_pragmas.cpp:335:5: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:335:5: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:335:5: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:335:5: note: node 0x48344b8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: op template: D.98976[0].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 0 D.98976[0].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 1 D.98976[0].a2 = 1;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	children 0x4834138
task3_variants/vec_all_pragmas.cpp:335:5: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: 	{ 0, 1 }
task3_variants/vec_all_pragmas.cpp:335:5: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:335:5: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:335:5: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:335:5: note: node 0x4833eb8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:335:5: note: op template: D.98976[1].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 0 D.98976[1].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 1 D.98976[1].L0 = 9.583999999999999463984323710974422283470630645751953125e-2;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	children 0x4833e38
task3_variants/vec_all_pragmas.cpp:335:5: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:335:5: note: 	{ 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 }
task3_variants/vec_all_pragmas.cpp:335:5: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:335:5: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:335:5: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:335:5: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: op template: D.98976[1].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 0 D.98976[1].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 1 D.98976[1].a2 = 2;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	children 0x4833fb8
task3_variants/vec_all_pragmas.cpp:335:5: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: 	{ 0, 2 }
task3_variants/vec_all_pragmas.cpp:335:5: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:335:5: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:335:5: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:335:5: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:335:5: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: op template: MEM[(struct _Vector_impl_data *)&waterbonds]._M_finish = 0B;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&waterbonds]._M_finish = 0B;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&waterbonds]._M_end_of_storage = 0B;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	children 0x4834438
task3_variants/vec_all_pragmas.cpp:335:5: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: 	{ 0B, 0B }
task3_variants/vec_all_pragmas.cpp:335:5: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&waterbonds]._M_finish = 0B;
task3_variants/vec_all_pragmas.cpp:335:5: note: vect_is_simple_use: operand 0B, type of def: constant
task3_variants/vec_all_pragmas.cpp:335:5: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:335:5: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&waterbonds]._M_finish
task3_variants/vec_all_pragmas.cpp:335:5: note: created &MEM[(struct _Vector_impl_data *)&waterbonds]._M_finish
task3_variants/vec_all_pragmas.cpp:335:5: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Bond * *)&waterbonds + 8B] = { 0, 0 };
task3_variants/vec_all_pragmas.cpp:335:5: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:335:5: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:335:5: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:335:5: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:335:5: note: op template: D.98976[0].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 0 D.98976[0].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 1 D.98976[0].L0 = 9.583999999999999463984323710974422283470630645751953125e-2;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	children 0x4834238
task3_variants/vec_all_pragmas.cpp:335:5: note: node (constant) 0x4834238 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:335:5: note: 	{ 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 }
task3_variants/vec_all_pragmas.cpp:335:5: note: ------>vectorizing SLP node starting from: D.98976[0].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: vect_is_simple_use: operand 9.583999999999999463984323710974422283470630645751953125e-2, type of def: constant
task3_variants/vec_all_pragmas.cpp:335:5: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:335:5: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: D.98976[0].K
task3_variants/vec_all_pragmas.cpp:335:5: note: created &D.98976[0]
task3_variants/vec_all_pragmas.cpp:335:5: note: add new stmt: MEM <vector(2) double> [(double *)&D.98976] = { 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 };
task3_variants/vec_all_pragmas.cpp:335:5: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:335:5: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:335:5: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:335:5: note: node 0x48344b8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: op template: D.98976[0].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 0 D.98976[0].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 1 D.98976[0].a2 = 1;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	children 0x4834138
task3_variants/vec_all_pragmas.cpp:335:5: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: 	{ 0, 1 }
task3_variants/vec_all_pragmas.cpp:335:5: note: ------>vectorizing SLP node starting from: D.98976[0].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: vect_is_simple_use: operand 1, type of def: constant
task3_variants/vec_all_pragmas.cpp:335:5: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:335:5: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: D.98976[0].a1
task3_variants/vec_all_pragmas.cpp:335:5: note: created &D.98976[0].a1
task3_variants/vec_all_pragmas.cpp:335:5: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int *)&D.98976 + 16B] = { 0, 1 };
task3_variants/vec_all_pragmas.cpp:335:5: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:335:5: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:335:5: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:335:5: note: node 0x4833eb8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:335:5: note: op template: D.98976[1].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 0 D.98976[1].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 1 D.98976[1].L0 = 9.583999999999999463984323710974422283470630645751953125e-2;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	children 0x4833e38
task3_variants/vec_all_pragmas.cpp:335:5: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:335:5: note: 	{ 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 }
task3_variants/vec_all_pragmas.cpp:335:5: note: ------>vectorizing SLP node starting from: D.98976[1].K = 2.0e+4;
task3_variants/vec_all_pragmas.cpp:335:5: note: vect_is_simple_use: operand 9.583999999999999463984323710974422283470630645751953125e-2, type of def: constant
task3_variants/vec_all_pragmas.cpp:335:5: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:335:5: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: D.98976[1].K
task3_variants/vec_all_pragmas.cpp:335:5: note: created &D.98976[1]
task3_variants/vec_all_pragmas.cpp:335:5: note: add new stmt: MEM <vector(2) double> [(double *)&D.98976 + 32B] = { 2.0e+4, 9.583999999999999463984323710974422283470630645751953125e-2 };
task3_variants/vec_all_pragmas.cpp:335:5: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:335:5: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:335:5: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:335:5: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: op template: D.98976[1].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 0 D.98976[1].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	stmt 1 D.98976[1].a2 = 2;
task3_variants/vec_all_pragmas.cpp:335:5: note: 	children 0x4833fb8
task3_variants/vec_all_pragmas.cpp:335:5: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:335:5: note: 	{ 0, 2 }
task3_variants/vec_all_pragmas.cpp:335:5: note: ------>vectorizing SLP node starting from: D.98976[1].a1 = 0;
task3_variants/vec_all_pragmas.cpp:335:5: note: vect_is_simple_use: operand 2, type of def: constant
task3_variants/vec_all_pragmas.cpp:335:5: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:335:5: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: D.98976[1].a1
task3_variants/vec_all_pragmas.cpp:335:5: note: created &D.98976[1].a1
task3_variants/vec_all_pragmas.cpp:335:5: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int *)&D.98976 + 48B] = { 0, 2 };
task3_variants/vec_all_pragmas.cpp:335:5: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:335:5: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:335:5: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:335:5: missed: splitting region at dominance boundary bb69
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 93
task3_variants/vec_all_pragmas.cpp:335:5: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:335:5: missed: splitting region at control altering definition _487 = operator new (40);
/usr/include/c++/13/bits/stl_algobase.h:437:23: missed: statement clobbers memory: __builtin_memcpy (_460, &D.98976, 64);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _487 = operator new (40);
/usr/include/c++/13/bits/stl_vector.h:100:16: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:16: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: op template: MEM[(struct _Vector_impl_data *)&waterangle]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&waterangle]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&waterangle]._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	children 0x4833fb8
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node 0x4833db8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: op template: MEM[(struct _Vector_impl_data *)&waterangle]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&waterangle]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&waterangle]._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	children 0x4833fb8
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node (constant) 0x4833fb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:16: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&waterangle]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:16: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:16: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&waterangle]._M_finish
/usr/include/c++/13/bits/stl_vector.h:100:16: note: created &MEM[(struct _Vector_impl_data *)&waterangle]._M_finish
/usr/include/c++/13/bits/stl_vector.h:100:16: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Angle * *)&waterangle + 8B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:16: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:16: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:16: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:16: missed: splitting region at dominance boundary bb71
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 94
/usr/include/c++/13/bits/stl_vector.h:100:16: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:16: missed: splitting region at control altering definition _508 = operator new (40);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _508 = operator new (40);
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: node 0x4833fb8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: op template: waterangle.D.90973._M_impl.D.90312._M_start = _487;
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: 	stmt 0 waterangle.D.90973._M_impl.D.90312._M_start = _487;
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: 	stmt 1 waterangle.D.90973._M_impl.D.90312._M_finish = _479;
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: 	children 0x4833eb8
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: node (external) 0x4833eb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: 	{ _487, _479 }
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:1692:6: note: Cost model analysis for part in loop 0:
  Vector cost: 32
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: op template: MEM[(struct _Vector_impl_data *)&D.99038]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99038]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99038]._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	children 0x48344b8
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: _487->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 _487->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 _487->Phi0 = 1.8229964037080772509824555527302436530590057373046875e+0;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ 1.0e+3, 1.8229964037080772509824555527302436530590057373046875e+0 }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: _487->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 _487->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 _487->a2 = 0;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ 1, 0 }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x4833fb8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: waterangle.D.90973._M_impl.D.90312._M_start = _487;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 waterangle.D.90973._M_impl.D.90312._M_start = _487;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 waterangle.D.90973._M_impl.D.90312._M_finish = _479;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x4833eb8
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (external) 0x4833eb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ _487, _479 }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ------>vectorizing SLP node starting from: waterangle.D.90973._M_impl.D.90312._M_start = _487;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vect_is_simple_use: operand _487 + 40, type of def: internal
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: waterangle.D.90973._M_impl.D.90312._M_start
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: created &waterangle
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Angle * *)&waterangle] = _1387;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_algobase.h:398:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99038]._M_finish = 0B;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99038]._M_finish = 0B;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99038]._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x48344b8
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (constant) 0x48344b8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99038]._M_finish = 0B;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99038]._M_finish
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: created &MEM[(struct _Vector_impl_data *)&D.99038]._M_finish
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Angle * *)&D.99038 + 8B] = { 0, 0 };
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_algobase.h:398:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: _487->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 _487->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 _487->Phi0 = 1.8229964037080772509824555527302436530590057373046875e+0;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ 1.0e+3, 1.8229964037080772509824555527302436530590057373046875e+0 }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ------>vectorizing SLP node starting from: _487->K = 1.0e+3;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vect_is_simple_use: operand 1.8229964037080772509824555527302436530590057373046875e+0, type of def: constant
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: _487->K
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: created vectp.1660_288
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1660_288] = { 1.0e+3, 1.8229964037080772509824555527302436530590057373046875e+0 };
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_algobase.h:398:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: op template: _487->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 0 _487->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	stmt 1 _487->a2 = 0;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: 	{ 1, 0 }
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ------>vectorizing SLP node starting from: _487->a1 = 1;
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vect_is_simple_use: operand 0, type of def: constant
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: _487->a1
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: created vectp.1662_306
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int *)vectp.1662_306] = { 1, 0 };
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_algobase.h:398:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_algobase.h:398:4: missed: splitting region at dominance boundary bb73
/usr/include/c++/13/bits/stl_algobase.h:398:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_algobase.h:398:4: missed: splitting region at control altering definition _543 = operator new (64);
/usr/include/c++/13/bits/stl_algobase.h:398:4: missed: not vectorized: more than one data ref in stmt: *_508 = MEM[(const struct Angle &)_487];
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _543 = operator new (64);
/usr/include/c++/13/bits/stl_vector.h:100:16: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:16: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: op template: MEM[(struct _Vector_impl_data *)&D.99037]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99037]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99037]._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:16: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: op template: MEM[(struct _Vector_impl_data *)&D.99037]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99037]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99037]._M_end_of_storage = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:16: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:16: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:16: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99037]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:16: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:16: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:16: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99037]._M_finish
/usr/include/c++/13/bits/stl_vector.h:100:16: note: created &MEM[(struct _Vector_impl_data *)&D.99037]._M_finish
/usr/include/c++/13/bits/stl_vector.h:100:16: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Bond * *)&D.99037 + 8B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:16: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:16: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:16: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:16: missed: splitting region at dominance boundary bb74
/usr/include/c++/13/bits/stl_vector.h:100:16: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:16: missed: splitting region at control altering definition _561 = std::__cxx11::basic_string<char>::_M_create (&MEM[(struct Atoms *)&D.99022].name, &__dnew, 0);
/usr/include/c++/13/bits/stl_algobase.h:437:23: missed: statement clobbers memory: __builtin_memcpy (_543, _460, 64);
/usr/include/c++/13/bits/basic_string.tcc:229:13: missed: not vectorized: statement can throw an exception: _561 = std::__cxx11::basic_string<char>::_M_create (&MEM[(struct Atoms *)&D.99022].name, &__dnew, 0);
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:109:7: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:109:7: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4833f38 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.99022].mass = _544;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.99022].mass = _544;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.99022].ep = _545;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.99022].sigma = _546;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.99022].charge = _547;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4834438
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834438 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _544 = MEM[(const struct Atoms &)&O].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _544 = MEM[(const struct Atoms &)&O].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _545 = MEM[(const struct Atoms &)&O].ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _546 = MEM[(const struct Atoms &)&O].sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _547 = MEM[(const struct Atoms &)&O].charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 112
task3_variants/vec_all_pragmas.cpp:109:7: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:109:7: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4833f38 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.99022].mass = _544;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.99022].mass = _544;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.99022].ep = _545;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.99022].sigma = _546;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.99022].charge = _547;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4834438
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834438 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _544 = MEM[(const struct Atoms &)&O].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _544 = MEM[(const struct Atoms &)&O].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _545 = MEM[(const struct Atoms &)&O].ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _546 = MEM[(const struct Atoms &)&O].sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _547 = MEM[(const struct Atoms &)&O].charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: _544 = MEM[(const struct Atoms &)&O].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: const vector(4) double  vectorizing a pointer ref: MEM[(const struct Atoms &)&O].mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created &MEM[(const struct Atoms &)&O]
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: vect__544.1667_917 = MEM <const vector(4) double> [(double *)&O];
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: MEM[(struct Atoms *)&D.99022].mass = _544;
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&O].mass, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&O].ep, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&O].sigma, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&O].charge, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: vector(4) double  vectorizing a pointer ref: MEM[(struct Atoms *)&D.99022].mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created &MEM[(struct Atoms *)&D.99022]
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: MEM <vector(4) double> [(double *)&D.99022] = vect__544.1667_917;
task3_variants/vec_all_pragmas.cpp:109:7: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:109:7: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb76
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb80
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb81
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_2061, _550, _551);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _591 = operator new (_1654);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _591 = operator new (_1654);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99022 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99022 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99022 + 64B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.99022 + 64B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb87
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb88
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _615 = operator new (_462);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1774 = *__first$_M_current_1618;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _615 = operator new (_462);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99022 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99022 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99022 + 88B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.99022 + 88B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb95
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb96
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _639 = operator new (_454);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2317 = *__first$_M_current_1640;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _639 = operator new (_454);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99022 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99022 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99022 + 112B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.99022 + 112B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb103
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb104
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _657 = std::__cxx11::basic_string<char>::_M_create (&MEM[(struct Atoms *)&D.99022 + 136B].name, &__dnew, 0);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2247 = *__first$_M_current_2291;
/usr/include/c++/13/bits/basic_string.tcc:229:13: missed: not vectorized: statement can throw an exception: _657 = std::__cxx11::basic_string<char>::_M_create (&MEM[(struct Atoms *)&D.99022 + 136B].name, &__dnew, 0);
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:109:7: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:109:7: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4833f38 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.99022 + 136B].mass = _640;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.99022 + 136B].mass = _640;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.99022 + 136B].ep = _641;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.99022 + 136B].sigma = _642;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.99022 + 136B].charge = _643;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4834438
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834438 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _640 = MEM[(const struct Atoms &)&H1].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _640 = MEM[(const struct Atoms &)&H1].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _641 = MEM[(const struct Atoms &)&H1].ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _642 = MEM[(const struct Atoms &)&H1].sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _643 = MEM[(const struct Atoms &)&H1].charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 112
task3_variants/vec_all_pragmas.cpp:109:7: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:109:7: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4833f38 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.99022 + 136B].mass = _640;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.99022 + 136B].mass = _640;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.99022 + 136B].ep = _641;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.99022 + 136B].sigma = _642;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.99022 + 136B].charge = _643;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4834438
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834438 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _640 = MEM[(const struct Atoms &)&H1].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _640 = MEM[(const struct Atoms &)&H1].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _641 = MEM[(const struct Atoms &)&H1].ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _642 = MEM[(const struct Atoms &)&H1].sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _643 = MEM[(const struct Atoms &)&H1].charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: _640 = MEM[(const struct Atoms &)&H1].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: const vector(4) double  vectorizing a pointer ref: MEM[(const struct Atoms &)&H1].mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created &MEM[(const struct Atoms &)&H1]
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: vect__640.1678_789 = MEM <const vector(4) double> [(double *)&H1];
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: MEM[(struct Atoms *)&D.99022 + 136B].mass = _640;
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H1].mass, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H1].ep, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H1].sigma, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H1].charge, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: vector(4) double  vectorizing a pointer ref: MEM[(struct Atoms *)&D.99022 + 136B].mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created &MEM[(struct Atoms *)&D.99022 + 136B]
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: MEM <vector(4) double> [(double *)&D.99022 + 136B] = vect__640.1678_789;
task3_variants/vec_all_pragmas.cpp:109:7: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:109:7: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb118
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb122
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb123
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_1644, _646, _647);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _687 = operator new (_1637);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _687 = operator new (_1637);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 200B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 200B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99022 + 200B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99022 + 200B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99022 + 200B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.99022 + 200B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb129
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb130
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _711 = operator new (_453);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_61 = *__first$_M_current_2203;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _711 = operator new (_453);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 224B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 224B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99022 + 224B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99022 + 224B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99022 + 224B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.99022 + 224B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb137
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb138
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _735 = operator new (_457);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1668 = *__first$_M_current_2088;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _735 = operator new (_457);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 248B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 248B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99022 + 248B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99022 + 248B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99022 + 248B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.99022 + 248B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb145
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb146
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _753 = std::__cxx11::basic_string<char>::_M_create (&MEM[(struct Atoms *)&D.99022 + 272B].name, &__dnew, 0);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_72 = *__first$_M_current_71;
/usr/include/c++/13/bits/basic_string.tcc:229:13: missed: not vectorized: statement can throw an exception: _753 = std::__cxx11::basic_string<char>::_M_create (&MEM[(struct Atoms *)&D.99022 + 272B].name, &__dnew, 0);
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:109:7: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:109:7: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4833f38 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.99022 + 272B].mass = _736;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.99022 + 272B].mass = _736;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.99022 + 272B].ep = _737;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.99022 + 272B].sigma = _738;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.99022 + 272B].charge = _739;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4834438
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834438 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _736 = MEM[(const struct Atoms &)&H2].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _736 = MEM[(const struct Atoms &)&H2].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _737 = MEM[(const struct Atoms &)&H2].ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _738 = MEM[(const struct Atoms &)&H2].sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _739 = MEM[(const struct Atoms &)&H2].charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 112
task3_variants/vec_all_pragmas.cpp:109:7: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:109:7: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4833f38 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: MEM[(struct Atoms *)&D.99022 + 272B].mass = _736;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 MEM[(struct Atoms *)&D.99022 + 272B].mass = _736;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 MEM[(struct Atoms *)&D.99022 + 272B].ep = _737;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 MEM[(struct Atoms *)&D.99022 + 272B].sigma = _738;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 MEM[(struct Atoms *)&D.99022 + 272B].charge = _739;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4834438
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834438 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _736 = MEM[(const struct Atoms &)&H2].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _736 = MEM[(const struct Atoms &)&H2].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _737 = MEM[(const struct Atoms &)&H2].ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _738 = MEM[(const struct Atoms &)&H2].sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _739 = MEM[(const struct Atoms &)&H2].charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: _736 = MEM[(const struct Atoms &)&H2].mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: const vector(4) double  vectorizing a pointer ref: MEM[(const struct Atoms &)&H2].mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created &MEM[(const struct Atoms &)&H2]
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: vect__736.1689_1095 = MEM <const vector(4) double> [(double *)&H2];
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: MEM[(struct Atoms *)&D.99022 + 272B].mass = _736;
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H2].mass, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H2].ep, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H2].sigma, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand MEM[(const struct Atoms &)&H2].charge, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: vector(4) double  vectorizing a pointer ref: MEM[(struct Atoms *)&D.99022 + 272B].mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created &MEM[(struct Atoms *)&D.99022 + 272B]
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: MEM <vector(4) double> [(double *)&D.99022 + 272B] = vect__736.1689_1095;
task3_variants/vec_all_pragmas.cpp:109:7: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:109:7: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb160
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb164
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb165
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_1779, _742, _743);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _783 = operator new (_2000);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _783 = operator new (_2000);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 336B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 336B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99022 + 336B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99022 + 336B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99022 + 336B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.99022 + 336B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb171
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb172
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _807 = operator new (_456);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1675 = *__first$_M_current_1673;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _807 = operator new (_456);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 360B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 360B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99022 + 360B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99022 + 360B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99022 + 360B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.99022 + 360B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb179
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb180
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _831 = operator new (_447);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2132 = *__first$_M_current_2131;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _831 = operator new (_447);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 384B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99022 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99022 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99022 + 384B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99022 + 384B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99022 + 384B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99022 + 384B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)&D.99022 + 384B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb187
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb188
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _855 = operator new (408);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1748 = *__first$_M_current_1684;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _855 = operator new (408);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99036]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99036]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99036]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99036]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99036]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99036]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99036]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99036]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99036]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Atoms * *)&D.99036] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb200
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _882 = std::__cxx11::basic_string<char>::_M_create (_869, &__dnew, 0);
/usr/include/c++/13/bits/basic_string.tcc:229:13: missed: not vectorized: statement can throw an exception: _882 = std::__cxx11::basic_string<char>::_M_create (_869, &__dnew, 0);
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:109:7: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:109:7: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834438 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: *__cur_1794.mass = _865;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 *__cur_1794.mass = _865;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 *__cur_1794.ep = _866;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 *__cur_1794.sigma = _867;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 *__cur_1794.charge = _868;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4834138
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834138 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _865 = *__first_1696.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _865 = *__first_1696.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _866 = *__first_1696.ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _867 = *__first_1696.sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _868 = *__first_1696.charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis for part in loop 24:
  Vector cost: 28
  Scalar cost: 112
task3_variants/vec_all_pragmas.cpp:109:7: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:109:7: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834438 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: *__cur_1794.mass = _865;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 *__cur_1794.mass = _865;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 *__cur_1794.ep = _866;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 *__cur_1794.sigma = _867;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 *__cur_1794.charge = _868;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4834138
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834138 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _865 = *__first_1696.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _865 = *__first_1696.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _866 = *__first_1696.ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _867 = *__first_1696.sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _868 = *__first_1696.charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: _865 = *__first_1696.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: const vector(4) double  vectorizing a pointer ref: *__first_1696.mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created vectp.1701_1130
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: vect__865.1702_527 = MEM <const vector(4) double> [(double *)vectp.1701_1130];
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: *__cur_1794.mass = _865;
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand *__first_1696.mass, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand *__first_1696.ep, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand *__first_1696.sigma, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand *__first_1696.charge, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: vector(4) double  vectorizing a pointer ref: *__cur_1794.mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created vectp.1704_203
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: MEM <vector(4) double> [(double *)vectp.1704_203] = vect__865.1702_527;
task3_variants/vec_all_pragmas.cpp:109:7: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:109:7: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb203
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb207
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb208
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_1669, _871, _872);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _912 = operator new (_1626);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _912 = operator new (_1626);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1794 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1794 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1794 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 24:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1794 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1794 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1794 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_1794 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_1794 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1706_913
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1706_913] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb217
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb218
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _936 = operator new (_446);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1491 = *__first$_M_current_1512;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _936 = operator new (_446);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1794 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1794 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1794 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 24:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1794 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1794 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1794 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_1794 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_1794 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1708_314
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1708_314] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb228
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb229
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _960 = operator new (_1998);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1708 = *__first$_M_current_2664;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _960 = operator new (_1998);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1794 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1794 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1794 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 24:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834438 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1794 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1794 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1794 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834138
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834138 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_1794 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_1794 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1710_1686
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1710_1686] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb239
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb240
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at loop 24 exit at bb252
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1486 = *__first$_M_current_1484;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at control altering definition _991 = operator new (_431);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _991 = operator new (_431);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834138 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&mols]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&mols]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&mols]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Atoms * *)&mols] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb268
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _1020 = std::__cxx11::basic_string<char>::_M_create (_1007, &__dnew, 0);
/usr/include/c++/13/bits/basic_string.tcc:229:13: missed: not vectorized: statement can throw an exception: _1020 = std::__cxx11::basic_string<char>::_M_create (_1007, &__dnew, 0);
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis succeeded with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:109:7: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&mols]._M_impl.D.93591._M_start = iftmp.98_984;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&mols]._M_impl.D.93591._M_start = iftmp.98_984;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct _Vector_base *)&mols]._M_impl.D.93591._M_finish = iftmp.98_984;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (external) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ iftmp.98_984, iftmp.98_984 }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis for part in loop 0:
  Vector cost: 20
  Scalar cost: 32
task3_variants/vec_all_pragmas.cpp:109:7: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834338 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: *__cur_85.mass = _1003;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 *__cur_85.mass = _1003;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 *__cur_85.ep = _1004;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 *__cur_85.sigma = _1005;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 *__cur_85.charge = _1006;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4833e38
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4833e38 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _1003 = *__first$_M_current_2326.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _1003 = *__first$_M_current_2326.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _1004 = *__first$_M_current_2326.ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _1005 = *__first$_M_current_2326.sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _1006 = *__first$_M_current_2326.charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:109:7: note: Cost model analysis for part in loop 29:
  Vector cost: 28
  Scalar cost: 112
task3_variants/vec_all_pragmas.cpp:109:7: note: Basic block will be vectorized using SLP
task3_variants/vec_all_pragmas.cpp:109:7: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: MEM[(struct _Vector_base *)&mols]._M_impl.D.93591._M_start = iftmp.98_984;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 MEM[(struct _Vector_base *)&mols]._M_impl.D.93591._M_start = iftmp.98_984;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 MEM[(struct _Vector_base *)&mols]._M_impl.D.93591._M_finish = iftmp.98_984;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4834438
task3_variants/vec_all_pragmas.cpp:109:7: note: node (external) 0x4834438 (max_nunits=1, refcnt=1) vector(2) long unsigned int
task3_variants/vec_all_pragmas.cpp:109:7: note: 	{ iftmp.98_984, iftmp.98_984 }
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_base *)&mols]._M_impl.D.93591._M_start = iftmp.98_984;
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand iftmp.98_984 = PHI <0B(252), _991(266)>, type of def: external
task3_variants/vec_all_pragmas.cpp:109:7: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_base *)&mols]._M_impl.D.93591._M_start
task3_variants/vec_all_pragmas.cpp:109:7: note: created &MEM[(struct _Vector_base *)&mols]
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Atoms * *)&mols] = _1514;
task3_variants/vec_all_pragmas.cpp:109:7: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:109:7: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:109:7: note: Vectorizing SLP tree:
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4834338 (max_nunits=4, refcnt=1) vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: *__cur_85.mass = _1003;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 *__cur_85.mass = _1003;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 *__cur_85.ep = _1004;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 *__cur_85.sigma = _1005;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 *__cur_85.charge = _1006;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	children 0x4833e38
task3_variants/vec_all_pragmas.cpp:109:7: note: node 0x4833e38 (max_nunits=4, refcnt=1) const vector(4) double
task3_variants/vec_all_pragmas.cpp:109:7: note: op template: _1003 = *__first$_M_current_2326.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 0 _1003 = *__first$_M_current_2326.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 1 _1004 = *__first$_M_current_2326.ep;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 2 _1005 = *__first$_M_current_2326.sigma;
task3_variants/vec_all_pragmas.cpp:109:7: note: 	stmt 3 _1006 = *__first$_M_current_2326.charge;
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: _1003 = *__first$_M_current_2326.mass;
task3_variants/vec_all_pragmas.cpp:109:7: note: transform load. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: const vector(4) double  vectorizing a pointer ref: *__first$_M_current_2326.mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created vectp.1716_309
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: vect__1003.1717_1172 = MEM <const vector(4) double> [(double *)vectp.1716_309];
task3_variants/vec_all_pragmas.cpp:109:7: note: ------>vectorizing SLP node starting from: *__cur_85.mass = _1003;
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand *__first$_M_current_2326.mass, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand *__first$_M_current_2326.ep, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand *__first$_M_current_2326.sigma, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: vect_is_simple_use: operand *__first$_M_current_2326.charge, type of def: internal
task3_variants/vec_all_pragmas.cpp:109:7: note: transform store. ncopies = 1
task3_variants/vec_all_pragmas.cpp:109:7: note: create vector_type-pointer variable to type: vector(4) double  vectorizing a pointer ref: *__cur_85.mass
task3_variants/vec_all_pragmas.cpp:109:7: note: created vectp.1719_1269
task3_variants/vec_all_pragmas.cpp:109:7: note: add new stmt: MEM <vector(4) double> [(double *)vectp.1719_1269] = vect__1003.1717_1172;
task3_variants/vec_all_pragmas.cpp:109:7: note: vectorizing stmts using SLP.
task3_variants/vec_all_pragmas.cpp:109:7: optimized: basic block part vectorized using 32 byte vectors
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb271
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb275
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb276
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_1643, _1009, _1010);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at control altering definition _1050 = operator new (_267);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1050 = operator new (_267);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_85 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_85 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_85 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 29:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_85 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_85 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_85 + 64B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_85 + 64B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_85 + 64B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1721_1318
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1721_1318] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb285
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb286
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1074 = operator new (_430);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1771 = *__first$_M_current_1719;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1074 = operator new (_430);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_85 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_85 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_85 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 29:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_85 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_85 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_85 + 88B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_85 + 88B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_85 + 88B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1723_1509
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1723_1509] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb296
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb297
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at control altering definition _1098 = operator new (_429);
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_2420 = *__first$_M_current_2419;
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1098 = operator new (_429);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_85 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_85 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_85 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 29:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_85 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_85 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_85 + 112B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_85 + 112B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_85 + 112B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1725_830
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Vec3 * *)vectp.1725_830] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb307
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb308
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_iterator.h:1077:9: missed: splitting region at loop 29 exit at bb533
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: more than one data ref in stmt: *__cur_1726 = *__first$_M_current_2422;
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at dominance boundary bb320
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at control altering definition _1125 = operator new (64);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1125 = operator new (64);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 24B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 24B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&mols + 24B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&mols + 24B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Bond * *)&mols + 24B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb331
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _1145 = operator new (40);
/usr/include/c++/13/bits/stl_algobase.h:437:23: missed: statement clobbers memory: __builtin_memcpy (_1125, _543, 64);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _1145 = operator new (40);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 48B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 48B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4834338 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&mols + 48B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&mols + 48B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct Angle * *)&mols + 48B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb332
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _69 = operator new (_2080);
/usr/include/c++/13/bits/stl_algobase.h:398:4: missed: not vectorized: more than one data ref in stmt: *_1145 = MEM[(const struct Angle &)_508];
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _69 = operator new (_2080);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 72B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&mols + 72B]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833e38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833e38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&mols + 72B]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&mols + 72B]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct vector * *)&mols + 72B] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb342
task3_variants/vec_all_pragmas.cpp:134:6: missed: statement clobbers memory: std::vector<Angle>::~vector (&mols.angles);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 113
task3_variants/vec_all_pragmas.cpp:134:6: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:134:6: missed: splitting region at dominance boundary bb345
task3_variants/vec_all_pragmas.cpp:134:6: missed: statement clobbers memory: std::vector<Bond>::~vector (&mols.bonds);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 112
task3_variants/vec_all_pragmas.cpp:134:6: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:134:6: missed: splitting region at dominance boundary bb335
task3_variants/vec_all_pragmas.cpp:134:6: missed: statement clobbers memory: std::vector<Atoms>::~vector (&mols.atoms);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 111
task3_variants/vec_all_pragmas.cpp:134:6: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:134:6: missed: splitting region at dominance boundary bb337
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1182]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1182]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1182]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)__cur_1182]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)__cur_1182]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)__cur_1182]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833f38
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833f38 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)__cur_1182]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)__cur_1182]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created vectp.1733_492
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int * *)vectp.1733_492] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb449
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1211, _1216);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1203, _1217);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1195, _1218);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1186, _1189);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_855, 408);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1250, _1255);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1242, _1256);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1234, _1257);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1225, _1228);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_543, 64);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_508, 40);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_487, 40);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_460, 64);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1540, _1545);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1532, _1546);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1524, _1547);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1515, _1518);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1574, _1579);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1566, _1580);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1558, _1581);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1549, _1552);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1608, _1613);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1600, _1614);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1592, _1615);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_1583, _1586);
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:106:4: note: SLPing BB part
task3_variants/vec_all_pragmas.cpp:356:28: note: Costing subgraph: 
task3_variants/vec_all_pragmas.cpp:356:28: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: op template: _48->x = _17;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 0 _48->x = _17;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 1 _48->y = _18;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	children 0x4834338
task3_variants/vec_all_pragmas.cpp:356:28: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: op template: _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 0 _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 1 _18 = _14 + 5.87079636588852260548065942202811129391193389892578125e-2;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	children 0x4834438 0x4833eb8
task3_variants/vec_all_pragmas.cpp:356:28: note: node 0x4834438 (max_nunits=2, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: op template: _13 = radius_99 * x_120;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 0 _13 = radius_99 * x_120;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 1 _14 = radius_99 * y_117;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	children 0x4834138 0x4833fb8
task3_variants/vec_all_pragmas.cpp:356:28: note: node (external) 0x4834138 (max_nunits=1, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: 	{ radius_99, radius_99 }
task3_variants/vec_all_pragmas.cpp:356:28: note: node (external) 0x4833fb8 (max_nunits=1, refcnt=2) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: 	{ x_120, y_117 }
task3_variants/vec_all_pragmas.cpp:356:28: note: node (constant) 0x4833eb8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: 	{ 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 }
task3_variants/vec_all_pragmas.cpp:356:28: note: node 0x4834238 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: op template: _122->x = _19;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 0 _122->x = _19;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 1 _122->y = _18;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	children 0x48341b8
task3_variants/vec_all_pragmas.cpp:356:28: note: node 0x48341b8 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: op template: _528 = .VEC_FMADDSUB (radius_99, x_120, 7.575407977810179327438078189516090787947177886962890625e-2);
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 0 _19 = _13 - 7.575407977810179327438078189516090787947177886962890625e-2;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 1 _18 = _14 + 5.87079636588852260548065942202811129391193389892578125e-2;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	children 0x4834138 0x4833fb8 0x48342b8
task3_variants/vec_all_pragmas.cpp:356:28: note: node (constant) 0x48342b8 (max_nunits=1, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: 	{ 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 }
task3_variants/vec_all_pragmas.cpp:356:28: note: node 0x4834538 (max_nunits=2, refcnt=1) vector(2) double
task3_variants/vec_all_pragmas.cpp:356:28: note: op template: _156->x = _13;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 0 _156->x = _13;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	stmt 1 _156->y = _14;
task3_variants/vec_all_pragmas.cpp:356:28: note: 	children 0x4834438
task3_variants/vec_all_pragmas.cpp:356:28: note: Cost model analysis: 
task3_variants/vec_all_pragmas.cpp:356:28: note: Cost model analysis for part in loop 2:
  Vector cost: 116
  Scalar cost: 156
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x48345b8 (max_nunits=4, refcnt=1) vector(4) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: MEM[(struct _Vector_impl_data *)_102(D)]._M_start = iftmp.98_984;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)_102(D)]._M_start = iftmp.98_984;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)_102(D)]._M_finish = __cur_86;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 2 MEM[(struct _Vector_impl_data *)_102(D)]._M_end_of_storage = _986;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 3 MEM[(struct _Vector_impl_data *)_102(D) + 24B]._M_start = _1125;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 4 MEM[(struct _Vector_impl_data *)_102(D) + 24B]._M_finish = _1120;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 5 MEM[(struct _Vector_impl_data *)_102(D) + 24B]._M_end_of_storage = _1120;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 6 MEM[(struct _Vector_impl_data *)_102(D) + 48B]._M_start = _1145;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 7 MEM[(struct _Vector_impl_data *)_102(D) + 48B]._M_finish = _1140;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 8 MEM[(struct _Vector_impl_data *)_102(D) + 48B]._M_end_of_storage = _1140;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 9 MEM[(struct _Vector_impl_data *)_102(D) + 72B]._M_start = iftmp.103_717;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 10 MEM[(struct _Vector_impl_data *)_102(D) + 72B]._M_finish = __cur_1489;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 11 MEM[(struct _Vector_impl_data *)_102(D) + 72B]._M_end_of_storage = _731;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x4834638
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x4834638 (max_nunits=1, refcnt=1) vector(4) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ iftmp.98_984, __cur_86, _986, _1125, _1120, _1120, _1145, _1140, _1140, iftmp.103_717, __cur_1489, _731 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Cost model analysis for part in loop 0:
  Vector cost: 288
  Scalar cost: 192
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: not vectorized: vectorization is not profitable.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x4833f38 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _48->x = _17;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _48->x = _17;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _48->y = _18;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x4834338
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x4834338 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _18 = _14 + 5.87079636588852260548065942202811129391193389892578125e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x4834438 0x4833eb8
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x4834438 (max_nunits=2, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _13 = radius_99 * x_120;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _13 = radius_99 * x_120;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _14 = radius_99 * y_117;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x4834138 0x4833fb8
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x4834138 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ radius_99, radius_99 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x4833fb8 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ x_120, y_117 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (constant) 0x4833eb8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _13 = radius_99 * x_120;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform binary/unary operation.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: vect__13.1734_2153 = _790 * _1520;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _17 = _13 + 7.575407977810179327438078189516090787947177886962890625e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand radius_99 * x_120, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform binary/unary operation.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: vect__17.1735_354 = vect__13.1734_2153 + { 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 };
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _48->x = _17;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand _13 + 7.575407977810179327438078189516090787947177886962890625e-2, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand _14 + 5.87079636588852260548065942202811129391193389892578125e-2, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:106:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: _48->x
/usr/include/c++/13/bits/stl_vector.h:106:4: note: created vectp.1737_886
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1737_886] = vect__17.1735_354;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x4834238 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _122->x = _19;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _122->x = _19;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _122->y = _18;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x48341b8
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x48341b8 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _528 = .VEC_FMADDSUB (radius_99, x_120, 7.575407977810179327438078189516090787947177886962890625e-2);
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _19 = _13 - 7.575407977810179327438078189516090787947177886962890625e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _18 = _14 + 5.87079636588852260548065942202811129391193389892578125e-2;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x4834138 0x4833fb8 0x48342b8
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x4834138 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ radius_99, radius_99 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x4833fb8 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ x_120, y_117 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (constant) 0x48342b8 (max_nunits=1, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _528 = .VEC_FMADDSUB (radius_99, x_120, 7.575407977810179327438078189516090787947177886962890625e-2);
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform call.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: vect__528.1738_12 = .VEC_FMADDSUB (_790, _1520, { 7.575407977810179327438078189516090787947177886962890625e-2, 5.87079636588852260548065942202811129391193389892578125e-2 });
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _122->x = _19;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand .VEC_FMADDSUB (radius_99, x_120, 7.575407977810179327438078189516090787947177886962890625e-2), type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand _14 + 5.87079636588852260548065942202811129391193389892578125e-2, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:106:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: _122->x
/usr/include/c++/13/bits/stl_vector.h:106:4: note: created vectp.1740_1521
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1740_1521] = vect__528.1738_12;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:106:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x4834538 (max_nunits=2, refcnt=1) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _156->x = _13;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _156->x = _13;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _156->y = _14;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x4834438
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node 0x4834438 (max_nunits=2, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: op template: _13 = radius_99 * x_120;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 0 _13 = radius_99 * x_120;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	stmt 1 _14 = radius_99 * y_117;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	children 0x4834138 0x4833fb8
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x4834138 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ radius_99, radius_99 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: node (external) 0x4833fb8 (max_nunits=1, refcnt=2) vector(2) double
/usr/include/c++/13/bits/stl_vector.h:106:4: note: 	{ x_120, y_117 }
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ------>vectorizing SLP node starting from: _156->x = _13;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand radius_99 * x_120, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vect_is_simple_use: operand radius_99 * y_117, type of def: internal
/usr/include/c++/13/bits/stl_vector.h:106:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:106:4: note: create vector_type-pointer variable to type: vector(2) double  vectorizing a pointer ref: _156->x
/usr/include/c++/13/bits/stl_vector.h:106:4: note: created vectp.1742_20
/usr/include/c++/13/bits/stl_vector.h:106:4: note: add new stmt: MEM <vector(2) double> [(double *)vectp.1742_20] = vect__13.1734_2153;
/usr/include/c++/13/bits/stl_vector.h:106:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:106:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: splitting region at dominance boundary bb450
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: splitting region at dominance boundary bb451
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: splitting region at dominance boundary bb301
/usr/include/c++/13/bits/stl_vector.h:106:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:106:4: missed: splitting region at dominance boundary bb312
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb452
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (_1014);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 120
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb290
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb315
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb453
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (_1012);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 119
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb279
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb318
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb322
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (_2308);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 118
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb265
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: _999 = __builtin_eh_pointer (117);
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_begin_catch (_999);
/usr/include/c++/13/bits/stl_uninitialized.h:126:4: missed: not vectorized: statement can throw an exception: __cxa_rethrow ();
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_end_catch ();
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 116
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (iftmp.98_984, _431);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 114
/usr/include/c++/13/bits/stl_construct.h:151:22: missed: statement clobbers memory: Atoms::~Atoms (__first_1000);
/usr/include/c++/13/bits/stl_construct.h:162:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:162:4: missed: splitting region at dominance boundary bb398
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb454
task3_variants/vec_all_pragmas.cpp:341:68: missed: statement clobbers memory: std::vector<Atoms>::~vector (&D.99036);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 53
task3_variants/vec_all_pragmas.cpp:341:68: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:341:68: missed: splitting region at dominance boundary bb455
task3_variants/vec_all_pragmas.cpp:341:68: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:341:68: missed: splitting region at dominance boundary bb233
task3_variants/vec_all_pragmas.cpp:341:68: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:341:68: missed: splitting region at dominance boundary bb244
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb456
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (_876);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 110
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb222
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb247
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb457
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (_874);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 109
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb211
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb250
/usr/include/c++/13/bits/new_allocator.h:140:28: missed: not vectorized: statement can throw an exception: std::__throw_bad_alloc ();
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb254
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (_2377);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 108
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb261
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: _861 = __builtin_eh_pointer (107);
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_begin_catch (_861);
/usr/include/c++/13/bits/stl_uninitialized.h:126:4: missed: not vectorized: statement can throw an exception: __cxa_rethrow ();
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_end_catch ();
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 106
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: splitting region at dominance boundary bb401
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_837, _961);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 104
/usr/include/c++/13/bits/new_allocator.h:172:26: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/new_allocator.h:172:26: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: splitting region at dominance boundary bb255
task3_variants/vec_all_pragmas.cpp:341:68: missed: statement clobbers memory: Atoms::~Atoms (&MEM <const struct Atoms[3]> [(void *)&D.99022 + 272B]);
task3_variants/vec_all_pragmas.cpp:341:68: missed: statement clobbers memory: Atoms::~Atoms (&MEM <const struct Atoms[3]> [(void *)&D.99022 + 136B]);
task3_variants/vec_all_pragmas.cpp:341:68: missed: statement clobbers memory: Atoms::~Atoms (&MEM <const struct Atoms[3]> [(void *)&D.99022]);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 50
task3_variants/vec_all_pragmas.cpp:341:68: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:341:68: missed: splitting region at dominance boundary bb458
/usr/include/c++/13/bits/stl_construct.h:151:22: missed: statement clobbers memory: Atoms::~Atoms (__first_862);
/usr/include/c++/13/bits/stl_construct.h:162:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:162:4: missed: splitting region at dominance boundary bb184
/usr/include/c++/13/bits/stl_construct.h:162:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:162:4: missed: splitting region at dominance boundary bb192
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb459
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (&MEM[(struct Atoms *)&D.99022 + 272B].v);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 103
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb176
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb195
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb460
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (&MEM[(struct Atoms *)&D.99022 + 272B].p);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 102
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb168
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb198
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb571
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&MEM[(struct Atoms *)&D.99022 + 272B].name);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 101
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb461
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb142
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb150
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb462
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (&MEM[(struct Atoms *)&D.99022 + 136B].v);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 100
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb134
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb153
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb463
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (&MEM[(struct Atoms *)&D.99022 + 136B].p);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 99
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb126
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb156
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb572
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&MEM[(struct Atoms *)&D.99022 + 136B].name);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 98
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb464
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb100
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb108
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb465
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (&MEM[(struct Atoms *)&D.99022].v);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 97
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb92
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb111
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb466
task3_variants/vec_all_pragmas.cpp:109:7: missed: statement clobbers memory: std::vector<Vec3>::~vector (&MEM[(struct Atoms *)&D.99022].p);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 96
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb84
task3_variants/vec_all_pragmas.cpp:109:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:109:7: missed: splitting region at dominance boundary bb114
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: not vectorized: statement can throw an exception: std::__throw_bad_array_new_length ();
/usr/include/c++/13/bits/new_allocator.h:139:41: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:139:41: missed: splitting region at dominance boundary bb573
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&MEM[(struct Atoms *)&D.99022].name);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 95
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb407
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:23: missed: splitting region at dominance boundary bb414
task3_variants/vec_all_pragmas.cpp:362:1: missed: statement clobbers memory: Atoms::~Atoms (_132);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 49
task3_variants/vec_all_pragmas.cpp:341:68: missed: statement clobbers memory: std::vector<Bond>::~vector (&D.99037);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 46
task3_variants/vec_all_pragmas.cpp:341:68: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:341:68: missed: splitting region at dominance boundary bb417
task3_variants/vec_all_pragmas.cpp:341:68: missed: statement clobbers memory: std::vector<Angle>::~vector (&D.99038);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 44
task3_variants/vec_all_pragmas.cpp:341:68: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:341:68: missed: splitting region at dominance boundary bb420
task3_variants/vec_all_pragmas.cpp:362:1: missed: statement clobbers memory: std::vector<Angle>::~vector (&waterangle);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 42
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb423
task3_variants/vec_all_pragmas.cpp:362:1: missed: statement clobbers memory: std::vector<Bond>::~vector (&waterbonds);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 35
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb426
task3_variants/vec_all_pragmas.cpp:362:1: missed: statement clobbers memory: Atoms::~Atoms (&H2);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 28
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb429
task3_variants/vec_all_pragmas.cpp:362:1: missed: statement clobbers memory: Atoms::~Atoms (&H1);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 19
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb467
task3_variants/vec_all_pragmas.cpp:362:1: missed: statement clobbers memory: Atoms::~Atoms (&O);
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb468
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb469
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb470
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb471
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb472
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb473
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb474
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb475
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb3
task3_variants/vec_all_pragmas.cpp:362:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:362:1: missed: splitting region at dominance boundary bb24
/usr/include/c++/13/bits/stl_vector.h:1910:24: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("cannot create std::vector larger than max_size()");
/usr/include/c++/13/bits/stl_vector.h:1910:24: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&O.name);
task3_variants/vec_all_pragmas.cpp:324:8: missed: not vectorized: statement can throw an exception: resx 84
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&D.98945);
/usr/include/c++/13/bits/basic_string.h:804:23: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:162:19: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_vector.h:733:7: note: vectorized 0 loops in function.
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_17, _20);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_14, _24);
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: statement clobbers memory: _66 = operator new (prephitmp_81);
/usr/include/c++/13/bits/stl_uninitialized.h:1131:21: missed: statement clobbers memory: __builtin_memmove (iftmp.20_24, _48, _1);
/usr/include/c++/13/bits/stl_uninitialized.h:1131:21: missed: statement clobbers memory: __builtin_memcpy (_92, __position_10, _94);
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_48, _67);
/usr/include/c++/13/bits/stl_vector.h:1899:24: missed: statement clobbers memory: std::__throw_length_error ("vector::_M_realloc_insert");
/usr/include/c++/13/bits/vector.tcc:521:30: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/vector.tcc:521:30: note: SLPing BB part
/usr/include/c++/13/bits/vector.tcc:521:30: note: Costing subgraph: 
/usr/include/c++/13/bits/vector.tcc:521:30: note: node 0x4bff8d8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: op template: this_18(D)->D.92018._M_impl.D.91362._M_start = iftmp.20_24;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 0 this_18(D)->D.92018._M_impl.D.91362._M_start = iftmp.20_24;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 1 this_18(D)->D.92018._M_impl.D.91362._M_finish = _95;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	children 0x4bff9d8
/usr/include/c++/13/bits/vector.tcc:521:30: note: node (external) 0x4bff9d8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	{ iftmp.20_24, _95 }
/usr/include/c++/13/bits/vector.tcc:521:30: note: Cost model analysis: 
/usr/include/c++/13/bits/vector.tcc:521:30: note: Cost model analysis for part in loop 0:
  Vector cost: 32
  Scalar cost: 32
/usr/include/c++/13/bits/vector.tcc:521:30: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/vector.tcc:521:30: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/vector.tcc:521:30: note: node 0x4bff8d8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: op template: this_18(D)->D.92018._M_impl.D.91362._M_start = iftmp.20_24;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 0 this_18(D)->D.92018._M_impl.D.91362._M_start = iftmp.20_24;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	stmt 1 this_18(D)->D.92018._M_impl.D.91362._M_finish = _95;
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	children 0x4bff9d8
/usr/include/c++/13/bits/vector.tcc:521:30: note: node (external) 0x4bff9d8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/vector.tcc:521:30: note: 	{ iftmp.20_24, _95 }
/usr/include/c++/13/bits/vector.tcc:521:30: note: ------>vectorizing SLP node starting from: this_18(D)->D.92018._M_impl.D.91362._M_start = iftmp.20_24;
/usr/include/c++/13/bits/vector.tcc:521:30: note: vect_is_simple_use: operand _92 + _94, type of def: internal
/usr/include/c++/13/bits/vector.tcc:521:30: note: transform store. ncopies = 1
/usr/include/c++/13/bits/vector.tcc:521:30: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: this_18(D)->D.92018._M_impl.D.91362._M_start
/usr/include/c++/13/bits/vector.tcc:521:30: note: created vectp.2017_58
/usr/include/c++/13/bits/vector.tcc:521:30: note: add new stmt: MEM <vector(2) long unsigned int> [(long unsigned int * *)vectp.2017_58] = _73;
/usr/include/c++/13/bits/vector.tcc:521:30: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/vector.tcc:521:30: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/vector.tcc:521:30: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: not vectorized: loop nest containing two or more consecutive inner loops cannot be vectorized
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_vector.h:1129:34: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/predefined_ops.h:270:17: missed: couldn't vectorize loop
/usr/include/c++/13/bits/predefined_ops.h:270:17: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_heap.h:422:31: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_heap.h:422:31: missed: not vectorized: number of iterations cannot be computed.
/usr/include/c++/13/bits/stl_algo.h:1636:54: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_algo.h:1636:54: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_heap.h:358:4: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_heap.h:358:4: missed: not vectorized: latch block not empty.
/usr/include/c++/13/bits/stl_vector.h:1129:34: optimized: loop vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:1129:34: optimized: loop vectorized using 16 byte vectors
task3_variants/vec_all_pragmas.cpp:180:6: note: vectorized 1 loops in function.
task3_variants/vec_all_pragmas.cpp:180:6: missed: splitting region at control altering definition _146 = operator new (_255);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: statement clobbers memory: _129 = operator new (_128);
/usr/include/c++/13/bits/stl_algobase.h:931:11: missed: statement clobbers memory: __builtin_memset (__first_130, 0, _455);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _146 = operator new (_255);
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:398:25: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x49b9cc8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&distances2]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&distances2]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&distances2]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x49b9d48
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x49b9d48 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x49b9e48 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&distances2]._M_impl.D.97419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&distances2]._M_impl.D.97419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 distances2.D.98080._M_impl.D.97419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x49b9ec8
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x49b9ec8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x49b9cc8 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_impl_data *)&distances2]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&distances2]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&distances2]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x49b9d48
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x49b9d48 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&distances2]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&distances2]._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_impl_data *)&distances2]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(double * *)&distances2] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node 0x49b9e48 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: op template: MEM[(struct _Vector_base *)&distances2]._M_impl.D.97419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 0 MEM[(struct _Vector_base *)&distances2]._M_impl.D.97419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	stmt 1 distances2.D.98080._M_impl.D.97419._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	children 0x49b9ec8
/usr/include/c++/13/bits/stl_vector.h:398:25: note: node (constant) 0x49b9ec8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:398:25: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_base *)&distances2]._M_impl.D.97419._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:398:25: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:398:25: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_base *)&distances2]._M_impl.D.97419._M_start
/usr/include/c++/13/bits/stl_vector.h:398:25: note: created &MEM[(struct _Vector_base *)&distances2]
/usr/include/c++/13/bits/stl_vector.h:398:25: note: add new stmt: MEM <vector(2) long unsigned int> [(double * *)&distances2] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:398:25: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:398:25: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at dominance boundary bb13
/usr/include/c++/13/bits/stl_vector.h:398:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:398:25: missed: splitting region at dominance boundary bb70
/usr/include/c++/13/bits/stl_algobase.h:931:11: missed: statement clobbers memory: __builtin_memset (__first_147, 0, _451);
/usr/include/c++/13/bits/stl_heap.h:356:22: missed: statement clobbers memory: std::__adjust_heap<__gnu_cxx::__normal_iterator<long unsigned int*, std::vector<long unsigned int> >, long int, long unsigned int, __gnu_cxx::__ops::_Iter_comp_iter<BuildNeighborList(System&)::<lambda(const size_t&, const size_t&)> > > (__first, __parent_187, _184, _191, __comp);
/usr/include/c++/13/bits/stl_heap.h:264:25: missed: statement clobbers memory: std::__adjust_heap<__gnu_cxx::__normal_iterator<long unsigned int*, std::vector<long unsigned int> >, long int, long unsigned int, __gnu_cxx::__ops::_Iter_comp_iter<BuildNeighborList(System&)::<lambda(const size_t&, const size_t&)> > > (__first, 0, _184, _168, __comp);
/usr/include/c++/13/bits/stl_heap.h:264:25: missed: statement clobbers memory: std::__adjust_heap<__gnu_cxx::__normal_iterator<long unsigned int*, std::vector<long unsigned int> >, long int, long unsigned int, __gnu_cxx::__ops::_Iter_comp_iter<BuildNeighborList(System&)::<lambda(const size_t&, const size_t&)> > > (__first, 0, _162, _158, __comp);
/usr/include/c++/13/bits/stl_vector.h:1292:21: missed: not vectorized: statement can throw an exception: std::vector<long unsigned int>::_M_realloc_insert<const long unsigned int&> (_101, D.120534, &k);
/usr/include/c++/13/bits/stl_vector.h:1292:21: missed: not vectorized: statement can throw an exception: std::vector<long unsigned int>::_M_realloc_insert<const long unsigned int&> (_99, D.120531, &k);
task3_variants/vec_all_pragmas.cpp:180:6: missed: not vectorized: statement can throw an exception: resx 13
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_146, _255);
task3_variants/vec_all_pragmas.cpp:180:6: missed: not vectorized: statement can throw an exception: resx 11
task3_variants/vec_all_pragmas.cpp:23:26: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:23:26: note: ***** The result for vector mode V32QI would be the same
task3_variants/vec_all_pragmas.cpp:23:26: note: ***** Re-trying analysis with vector mode V16QI
task3_variants/vec_all_pragmas.cpp:23:26: note: ***** Analysis failed with vector mode V16QI
task3_variants/vec_all_pragmas.cpp:23:26: note: ***** Re-trying analysis with vector mode V8QI
task3_variants/vec_all_pragmas.cpp:23:26: note: ***** Analysis failed with vector mode V8QI
task3_variants/vec_all_pragmas.cpp:23:26: note: ***** Re-trying analysis with vector mode V4QI
task3_variants/vec_all_pragmas.cpp:23:26: note: ***** Analysis failed with vector mode V4QI
task3_variants/vec_all_pragmas.cpp:23:26: missed: splitting region at dominance boundary bb54
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_266, _271);
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb48
/usr/include/c++/13/bits/stl_vector.h:738:7: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:738:7: missed: splitting region at dominance boundary bb55
/usr/include/c++/13/bits/stl_vector.h:1288:6: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:1288:6: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_vector.h:1288:6: missed: splitting region at loop 2 exit at bb57
task3_variants/vec_all_pragmas.cpp:209:32: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:209:32: missed: splitting region at loop 1 exit at bb115
task3_variants/vec_all_pragmas.cpp:187:25: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:187:25: missed: splitting region at dominance boundary bb31
task3_variants/vec_all_pragmas.cpp:187:25: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:187:25: missed: splitting region at dominance boundary bb60
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_146, _255);
/usr/include/c++/13/bits/stl_vector.h:370:35: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:370:35: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_vector.h:370:35: missed: splitting region at dominance boundary bb80
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (prephitmp_486, _253);
task3_variants/vec_all_pragmas.cpp:220:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:220:1: missed: splitting region at dominance boundary bb56
task3_variants/vec_all_pragmas.cpp:220:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:220:1: missed: splitting region at dominance boundary bb82
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: splitting region at dominance boundary bb83
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: splitting region at dominance boundary bb84
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1129:25: missed: splitting region at dominance boundary bb3
/usr/include/c++/13/bits/stl_vector.h:1129:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:1910:24: missed: statement clobbers memory: std::__throw_length_error ("cannot create std::vector larger than max_size()");
/usr/include/c++/13/bits/stl_vector.h:1910:24: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: couldn't vectorize loop
/usr/include/c++/13/bits/stl_construct.h:119:7: missed: not vectorized: control flow in loop.
/usr/include/c++/13/bits/stl_uninitialized.h:113:5: note: vectorized 0 loops in function.
/usr/include/c++/13/bits/stl_uninitialized.h:113:5: missed: splitting region at control altering definition _29 = std::__cxx11::basic_string<char>::_M_create (__cur_55, &__dnew, 0);
/usr/include/c++/13/bits/char_traits.h:399:25: missed: statement clobbers memory: _25 = __builtin_strlen (_16);
/usr/include/c++/13/bits/basic_string.tcc:229:13: missed: not vectorized: statement can throw an exception: _29 = std::__cxx11::basic_string<char>::_M_create (__cur_55, &__dnew, 0);
/usr/include/c++/13/bits/basic_string.tcc:229:13: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.tcc:229:13: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.tcc:229:13: missed: splitting region at dominance boundary bb8
/usr/include/c++/13/bits/basic_string.tcc:229:13: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/basic_string.tcc:229:13: missed: splitting region at dominance boundary bb12
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:250:31: missed: splitting region at dominance boundary bb13
/usr/include/c++/13/bits/char_traits.h:435:49: missed: statement clobbers memory: __builtin_memcpy (_2, _16, _25);
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/basic_string.h:223:28: missed: splitting region at loop 1 exit at bb26
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at dominance boundary bb14
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:119:19: missed: splitting region at dominance boundary bb22
/usr/include/c++/13/bits/stl_uninitialized.h:121:11: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:121:11: missed: splitting region at dominance boundary bb4
/usr/include/c++/13/bits/stl_uninitialized.h:121:11: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:121:11: missed: splitting region at dominance boundary bb16
/usr/include/c++/13/bits/basic_string.h:646:28: missed: not vectorized: statement can throw an exception: std::__throw_logic_error ("basic_string: construction from null is not valid");
/usr/include/c++/13/bits/basic_string.h:646:28: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: _1 = __builtin_eh_pointer (1);
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_begin_catch (_1);
/usr/include/c++/13/bits/stl_uninitialized.h:126:4: missed: not vectorized: statement can throw an exception: __cxa_rethrow ();
/usr/include/c++/13/bits/stl_uninitialized.h:123:7: missed: statement clobbers memory: __cxa_end_catch ();
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (__first_17);
/usr/include/c++/13/bits/stl_construct.h:162:4: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:388:18: missed: couldn't vectorize loop
task3_variants/vec_all_pragmas.cpp:388:18: missed: not vectorized: control flow in loop.
task3_variants/vec_all_pragmas.cpp:377:5: note: vectorized 0 loops in function.
task3_variants/vec_all_pragmas.cpp:377:5: missed: splitting region at control altering definition _133 = operator new (_179);
/usr/include/c++/13/bits/new_allocator.h:151:48: missed: not vectorized: statement can throw an exception: _133 = operator new (_179);
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis succeeded with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:100:4: note: SLPing BB part
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Costing subgraph: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99302]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99302]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99302]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833eb8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833eb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis: 
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Cost model analysis for part in loop 0:
  Vector cost: 28
  Scalar cost: 32
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Basic block will be vectorized using SLP
/usr/include/c++/13/bits/stl_vector.h:100:4: note: Vectorizing SLP tree:
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node 0x4833e38 (max_nunits=2, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: op template: MEM[(struct _Vector_impl_data *)&D.99302]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 0 MEM[(struct _Vector_impl_data *)&D.99302]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	stmt 1 MEM[(struct _Vector_impl_data *)&D.99302]._M_finish = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	children 0x4833eb8
/usr/include/c++/13/bits/stl_vector.h:100:4: note: node (constant) 0x4833eb8 (max_nunits=1, refcnt=1) vector(2) long unsigned int
/usr/include/c++/13/bits/stl_vector.h:100:4: note: 	{ 0B, 0B }
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ------>vectorizing SLP node starting from: MEM[(struct _Vector_impl_data *)&D.99302]._M_start = 0B;
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vect_is_simple_use: operand 0B, type of def: constant
/usr/include/c++/13/bits/stl_vector.h:100:4: note: transform store. ncopies = 1
/usr/include/c++/13/bits/stl_vector.h:100:4: note: create vector_type-pointer variable to type: vector(2) long unsigned int  vectorizing a pointer ref: MEM[(struct _Vector_impl_data *)&D.99302]._M_start
/usr/include/c++/13/bits/stl_vector.h:100:4: note: created &MEM[(struct _Vector_impl_data *)&D.99302]
/usr/include/c++/13/bits/stl_vector.h:100:4: note: add new stmt: MEM <vector(2) long unsigned int> [(struct basic_string * *)&D.99302] = { 0, 0 };
/usr/include/c++/13/bits/stl_vector.h:100:4: note: vectorizing stmts using SLP.
/usr/include/c++/13/bits/stl_vector.h:100:4: optimized: basic block part vectorized using 32 byte vectors
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** The result for vector mode V32QI would be the same
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb62
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at dominance boundary bb7
/usr/include/c++/13/bits/stl_vector.h:100:4: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_vector.h:100:4: missed: splitting region at control altering definition _128 = std::__do_uninit_copy<char**, std::__cxx11::basic_string<char>*> (argv_21(D), _3, iftmp.115_125);
/usr/include/c++/13/bits/stl_uninitialized.h:137:32: missed: not vectorized: statement can throw an exception: _128 = std::__do_uninit_copy<char**, std::__cxx11::basic_string<char>*> (argv_21(D), _3, iftmp.115_125);
/usr/include/c++/13/bits/stl_uninitialized.h:137:32: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_uninitialized.h:137:32: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/bits/stl_uninitialized.h:137:32: missed: splitting region at dominance boundary bb9
/usr/include/c++/13/bits/stl_uninitialized.h:137:32: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/stl_uninitialized.h:137:32: missed: splitting region at control altering definition sys = MakeWater (_4); [return slot optimization]
task3_variants/vec_all_pragmas.cpp:378:43: missed: not vectorized: statement can throw an exception: Sim_Configuration::Sim_Configuration (&sc, &D.99302);
task3_variants/vec_all_pragmas.cpp:378:43: missed: statement clobbers memory: std::vector<std::__cxx11::basic_string<char> >::~vector (&D.99302);
task3_variants/vec_all_pragmas.cpp:380:38: missed: not vectorized: statement can throw an exception: sys = MakeWater (_4); [return slot optimization]
task3_variants/vec_all_pragmas.cpp:380:38: note: ***** Analysis failed with vector mode V4DI
task3_variants/vec_all_pragmas.cpp:380:38: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
task3_variants/vec_all_pragmas.cpp:380:38: missed: splitting region at control altering definition _53 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_bond.109_9);
task3_variants/vec_all_pragmas.cpp:381:35: missed: not vectorized: statement can throw an exception: std::basic_ofstream<char>::basic_ofstream (&file, &sc.filename, 16);
task3_variants/vec_all_pragmas.cpp:383:16: missed: not vectorized: statement can throw an exception: WriteOutput (&sys, &file);
task3_variants/vec_all_pragmas.cpp:385:58: missed: statement clobbers memory: tstart = std::chrono::_V2::system_clock::now ();
task3_variants/vec_all_pragmas.cpp:389:30: missed: not vectorized: statement can throw an exception: BuildNeighborList (&sys);
task3_variants/vec_all_pragmas.cpp:391:25: missed: statement clobbers memory: UpdateBondForces (&sys);
task3_variants/vec_all_pragmas.cpp:392:26: missed: statement clobbers memory: UpdateAngleForces (&sys);
task3_variants/vec_all_pragmas.cpp:393:30: missed: statement clobbers memory: UpdateNonBondedForces (&sys);
task3_variants/vec_all_pragmas.cpp:394:18: missed: statement clobbers memory: UpdateKDK (&sys, &sc);
task3_variants/vec_all_pragmas.cpp:397:24: missed: not vectorized: statement can throw an exception: WriteOutput (&sys, &file);
task3_variants/vec_all_pragmas.cpp:400:56: missed: statement clobbers memory: tend = std::chrono::_V2::system_clock::now ();
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "Accumulated forces Bonds   : ", 29);
/usr/include/c++/13/ostream:223:25: missed: not vectorized: statement can throw an exception: _53 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_bond.109_9);
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/ostream:223:25: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb29
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:223:25: missed: splitting region at control altering definition _61 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_angle.110_10);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (_53, "\n", 1);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "Accumulated forces Angles  : ", 29);
/usr/include/c++/13/ostream:223:25: missed: not vectorized: statement can throw an exception: _61 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_angle.110_10);
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/ostream:223:25: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb35
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:223:25: missed: splitting region at control altering definition _69 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_non_bond.111_11);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (_61, "\n", 1);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "Accumulated forces Non-bond: ", 29);
/usr/include/c++/13/ostream:223:25: missed: not vectorized: statement can throw an exception: _69 = std::basic_ostream<char>::_M_insert<double> (&cout, accumulated_forces_non_bond.111_11);
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/ostream:223:25: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb41
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:223:25: missed: splitting region at control altering definition _81 = std::basic_ostream<char>::_M_insert<double> (&cout, _13);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (_69, "\n", 1);
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (&cout, "Elapsed total time:       ", 26);
/usr/include/c++/13/ostream:223:25: missed: not vectorized: statement can throw an exception: _81 = std::basic_ostream<char>::_M_insert<double> (&cout, _13);
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/ostream:223:25: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb47
/usr/include/c++/13/ostream:223:25: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/ostream:223:25: missed: splitting region at dominance boundary bb60
/usr/include/c++/13/ostream:667:18: missed: not vectorized: statement can throw an exception: std::__ostream_insert<char, std::char_traits<char> > (_81, "\n", 1);
task3_variants/vec_all_pragmas.cpp:410:1: missed: statement clobbers memory: std::basic_ofstream<char>::~basic_ofstream (&file);
task3_variants/vec_all_pragmas.cpp:137:7: missed: statement clobbers memory: Molecules::~Molecules (&sys.molecules);
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&sc.filename);
task3_variants/vec_all_pragmas.cpp:410:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:410:1: missed: splitting region at dominance boundary bb24
task3_variants/vec_all_pragmas.cpp:410:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:410:1: missed: splitting region at dominance boundary bb21
task3_variants/vec_all_pragmas.cpp:410:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:410:1: missed: splitting region at dominance boundary bb51
task3_variants/vec_all_pragmas.cpp:410:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:410:1: missed: splitting region at dominance boundary bb52
task3_variants/vec_all_pragmas.cpp:410:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:410:1: missed: splitting region at dominance boundary bb54
task3_variants/vec_all_pragmas.cpp:410:1: missed: statement clobbers memory: std::basic_ofstream<char>::~basic_ofstream (&file);
task3_variants/vec_all_pragmas.cpp:377:5: missed: not vectorized: statement can throw an exception: resx 12
task3_variants/vec_all_pragmas.cpp:410:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:410:1: missed: splitting region at dominance boundary bb55
task3_variants/vec_all_pragmas.cpp:410:1: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:410:1: missed: splitting region at dominance boundary bb57
task3_variants/vec_all_pragmas.cpp:137:7: missed: statement clobbers memory: Molecules::~Molecules (&sys.molecules);
task3_variants/vec_all_pragmas.cpp:377:5: missed: not vectorized: statement can throw an exception: resx 11
task3_variants/vec_all_pragmas.cpp:137:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:137:7: missed: splitting region at dominance boundary bb58
task3_variants/vec_all_pragmas.cpp:137:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:137:7: missed: splitting region at dominance boundary bb50
/usr/include/c++/13/bits/basic_string.h:804:19: missed: statement clobbers memory: std::__cxx11::basic_string<char>::_M_dispose (&sc.filename);
task3_variants/vec_all_pragmas.cpp:145:7: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:145:7: missed: splitting region at dominance boundary bb3
task3_variants/vec_all_pragmas.cpp:378:43: missed: statement clobbers memory: std::vector<std::__cxx11::basic_string<char> >::~vector (&D.99302);
task3_variants/vec_all_pragmas.cpp:378:43: note: ***** Analysis failed with vector mode VOID
task3_variants/vec_all_pragmas.cpp:378:43: missed: splitting region at dominance boundary bb11
/usr/include/c++/13/bits/stl_vector.h:1910:24: missed: not vectorized: statement can throw an exception: std::__throw_length_error ("cannot create std::vector larger than max_size()");
/usr/include/c++/13/bits/stl_vector.h:1910:24: note: ***** Analysis failed with vector mode VOID
/usr/include/c++/13/bits/new_allocator.h:172:26: missed: statement clobbers memory: operator delete (_114, _134);
/usr/include/c++/13/bits/stl_vector.h:371:7: note: ***** Analysis failed with vector mode V4DI
/usr/include/c++/13/bits/stl_vector.h:371:7: note: ***** Skipping vector mode V32QI, which would repeat the analysis for V4DI
